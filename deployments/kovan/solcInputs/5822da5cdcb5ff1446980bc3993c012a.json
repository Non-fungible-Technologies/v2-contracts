{
  "language": "Solidity",
  "sources": {
    "contracts/ERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./interfaces/IERC721Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\nimport { ERC721P_DeadlineExpired, ERC721P_NotTokenOwner, ERC721P_InvalidSignature } from \"./errors/LendingUtils.sol\";\n\n/**\n * @title ERC721Permit\n * @author Non-Fungible Technologies, Inc.\n *\n * @dev Implementation of the ERC721 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol\n *\n * Adds the {permit} method, which can be used to change an account's ERC721 allowance (see {IERC721-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC721-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC721Permit is ERC721, IERC721Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    // ============================================ STATE ==============================================\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n\n    /// @dev Nonce for permit signatures.\n    mapping(address => Counters.Counter) private _nonces;\n\n    // ========================================== CONSTRUCTOR ===========================================\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC721 token name.\n     *\n     * @param name                  The name of the signing domain.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    // ===================================== PERMIT FUNCTIONALITY =======================================\n\n    /**\n     * @notice Allows the spender to spend the token ID which is owned by owner,\n     * given owner's signed approval.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `owner` must be the owner of `tokenId`.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * @param owner                 The owner of the token being permitted.\n     * @param spender               The address allowed to spend the token.\n     * @param tokenId               The token ID of the given asset.\n     * @param deadline              The maximum timestamp the signature is valid for.\n     * @param v                     Component of the signature.\n     * @param r                     Component of the signature.\n     * @param s                     Component of the signature.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        if (block.timestamp > deadline) revert ERC721P_DeadlineExpired(deadline);\n        if (owner != ERC721.ownerOf(tokenId)) revert ERC721P_NotTokenOwner(owner);\n\n        bytes32 structHash = keccak256(\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, tokenId, _useNonce(owner), deadline)\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) revert ERC721P_InvalidSignature(signer);\n\n        _approve(spender, tokenId);\n    }\n\n    /**\n     * @notice Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated.\n     *\n     * Every successful call to permit increases the owner's nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * @param owner                 The given owner to check the nonce for.\n     *\n     * @return current              The current noonce for the owner.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @notice Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     *\n     * @return separator             The bytes for the domain separator.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev Consumes the nonce - returns the current value and increments.\n     *\n     * @param owner                 The address of the user to consume a nonce for.\n     *\n     * @return current              The current nonce, before incrementation.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "contracts/interfaces/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IERC721Permit is IERC721 {\n    // ================ Permit Functionality ================\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    // ================ View Functions ================\n\n    function nonces(address owner) external view returns (uint256);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/errors/LendingUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../libraries/LoanLibrary.sol\";\n\n/**\n * @title LendingUtilsErrors\n * @author Non-Fungible Technologies, Inc.\n *\n * This file contains custom errors for utilities used by the lending protocol contracts.\n * Errors are prefixed by the contract that throws them (e.g., \"PR_\" for PunkRouter).\n */\n\n// ==================================== ERC721 Permit ======================================\n/// @notice All errors prefixed with ERC721P_, to separate from other contracts in the protocol.\n\n/**\n * @notice Deadline for the permit has expired.\n *\n * @param deadline                      Permit deadline parameter as a timestamp.\n */\nerror ERC721P_DeadlineExpired(uint256 deadline);\n\n/**\n * @notice Address of the owner to also be the owner of the tokenId.\n *\n * @param owner                        Owner parameter for the function call.\n */\nerror ERC721P_NotTokenOwner(address owner);\n\n/**\n * @notice Invalid signature.\n *\n * @param signer                        Signer recovered from ECDSA sugnature hash.\n */\nerror ERC721P_InvalidSignature(address signer);\n\n// ==================================== Punk Router ======================================\n/// @notice All errors prefixed with PR_, to separate from other contracts in the protocol.\n\n/**\n * @notice Not the owner of the specified punkIndex.\n *\n * @param caller                        Msg.sender of the function call.\n */\nerror PR_NotOwner(address caller);\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/libraries/LoanLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/**\n * @title LoanLibrary\n * @author Non-Fungible Technologies, Inc.\n *\n * Contains all data types used across Arcade lending contracts.\n */\nlibrary LoanLibrary {\n    /**\n     * @dev Enum describing the current state of a loan.\n     * State change flow:\n     * Created -> Active -> Repaid\n     *                   -> Defaulted\n     */\n    enum LoanState {\n        // We need a default that is not 'Created' - this is the zero value\n        DUMMY_DO_NOT_USE,\n        // The loan has been initialized, funds have been delivered to the borrower and the collateral is held.\n        Active,\n        // The loan has been repaid, and the collateral has been returned to the borrower. This is a terminal state.\n        Repaid,\n        // The loan was delinquent and collateral claimed by the lender. This is a terminal state.\n        Defaulted\n    }\n\n    /**\n     * @dev The raw terms of a loan.\n     */\n    struct LoanTerms {\n        /// @dev Packed variables\n        // The number of seconds representing relative due date of the loan.\n        /// @dev Max is 94,608,000, fits in 32 bits\n        uint32 durationSecs;\n        // Timestamp for when signature for terms expires\n        uint32 deadline;\n        // Total number of installment periods within the loan duration.\n        /// @dev Max is 1,000,000, fits in 24 bits\n        uint24 numInstallments;\n        // Interest expressed as a rate, unlike V1 gross value.\n        // Input conversion: 0.01% = (1 * 10**18) ,  10.00% = (1000 * 10**18)\n        // This represents the rate over the lifetime of the loan, not APR.\n        // 0.01% is the minimum interest rate allowed by the protocol.\n        /// @dev Max is 10,000%, fits in 160 bits\n        uint160 interestRate;\n        /// @dev Full-slot variables\n        // The amount of principal in terms of the payableCurrency.\n        uint256 principal;\n        // The token ID of the address holding the collateral.\n        /// @dev Can be an AssetVault, or the NFT contract for unbundled collateral\n        address collateralAddress;\n        // The token ID of the collateral.\n        uint256 collateralId;\n        // The payable currency for the loan principal and interest.\n        address payableCurrency;\n    }\n\n    /**\n     * @dev Modification of loan terms, used for signing only.\n     *      Instead of a collateralId, a list of predicates\n     *      is defined by 'bytes' in items.\n     */\n    struct LoanTermsWithItems {\n        /// @dev Packed variables\n        // The number of seconds representing relative due date of the loan.\n        /// @dev Max is 94,608,000, fits in 32 bits\n        uint32 durationSecs;\n        // Timestamp for when signature for terms expires\n        uint32 deadline;\n        // Total number of installment periods within the loan duration.\n        /// @dev Max is 1,000,000, fits in 24 bits\n        uint24 numInstallments;\n        // Interest expressed as a rate, unlike V1 gross value.\n        // Input conversion: 0.01% = (1 * 10**18) ,  10.00% = (1000 * 10**18)\n        // This represents the rate over the lifetime of the loan, not APR.\n        // 0.01% is the minimum interest rate allowed by the protocol.\n        /// @dev Max is 10,000%, fits in 160 bits\n        uint160 interestRate;\n        /// @dev Full-slot variables\n        uint256 principal;\n        // The tokenID of the address holding the collateral\n        /// @dev Must be an AssetVault for LoanTermsWithItems\n        address collateralAddress;\n        // An encoded list of predicates\n        bytes items;\n        // The payable currency for the loan principal and interest\n        address payableCurrency;\n    }\n\n    /**\n     * @dev Predicate for item-based verifications\n     */\n    struct Predicate {\n        // The encoded predicate, to decoded and parsed by the verifier contract\n        bytes data;\n        // The verifier contract\n        address verifier;\n    }\n\n    /**\n     * @dev The data of a loan. This is stored once the loan is Active\n     */\n    struct LoanData {\n        /// @dev Packed variables\n        // The current state of the loan\n        LoanState state;\n        // Number of installment payments made on the loan\n        uint24 numInstallmentsPaid;\n        // installment loan specific\n        // Start date of the loan, using block.timestamp - for determining installment period\n        uint160 startDate;\n        /// @dev Full-slot variables\n        // The raw terms of the loan\n        LoanTerms terms;\n        // Remaining balance of the loan. Starts as equal to principal. Can reduce based on\n        // payments made, can increased based on compounded interest from missed payments and late fees\n        uint256 balance;\n        // Amount paid in total by the borrower\n        uint256 balancePaid;\n        // Total amount of late fees accrued\n        uint256 lateFeesAccrued;\n    }\n}\n"
    },
    "contracts/PromissoryNote.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"./ERC721Permit.sol\";\nimport \"./interfaces/ILoanCore.sol\";\nimport \"./interfaces/IPromissoryNote.sol\";\n\nimport { PN_MintingRole, PN_BurningRole, PN_ContractPaused, PN_CannotInitialize, PN_AlreadyInitialized } from \"./errors/Lending.sol\";\nimport { ERC721P_InvalidSignature, ERC721P_DeadlineExpired } from \"./errors/LendingUtils.sol\";\n\n/**\n * @title PromissoryNote\n * @author Non-Fungible Technologies, Inc.\n *\n * Built off Openzeppelin's ERC721PresetMinterPauserAutoId. Used for\n * representing rights and obligations in the context of a loan - the\n * right to claim collateral for lenders (instantiated as LenderNote),\n * and the right to recover collateral upon repayment for borrowers\n * (instantiated as BorrowerNote).\n *\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract PromissoryNote is\n    Context,\n    AccessControlEnumerable,\n    ERC721Enumerable,\n    ERC721Pausable,\n    ERC721Permit,\n    IPromissoryNote\n{\n    using Counters for Counters.Counter;\n\n    // ============================================ STATE ==============================================\n\n    // =================== Constants =====================\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    // ============= Loan State ==============\n\n    /// @dev Initially deployer, then account with burn/mint/pause roles (LoanCore).\n    address public owner;\n    bool private initialized;\n\n    Counters.Counter private _tokenIdTracker;\n\n    // ========================================= CONSTRUCTOR ===========================================\n\n    /**\n     * @dev Creates the promissory note contract, granting minter, burner\n     *      and pauser roles to the specified owner address (which in practice\n     *      will be LoanCore).\n     *\n     * @param name                  The name of the token (see ERC721).\n     * @param symbol                The symbol of the token (see ERC721).\nå     */\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) ERC721Permit(name) {\n        // We don't want token IDs of 0\n        _tokenIdTracker.increment();\n\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Grants owner access to the specified address, which should be an\n     *         instance of LoanCore. Once admin role is set, it is immutable,\n     *         and cannot be set again.\n     *\n     * @param loanCore              The address of the admin.\n     */\n    function initialize(address loanCore) external {\n        if (initialized) revert PN_AlreadyInitialized();\n        if (_msgSender() != owner) revert PN_CannotInitialize();\n\n        _setupRole(ADMIN_ROLE, loanCore);\n\n        owner = loanCore;\n        initialized = true;\n    }\n\n    // ======================================= TOKEN OPERATIONS =========================================\n\n    /**\n     * @notice Create a new token and assign it to a specified owner. The token ID\n     *         should match the loan ID, and can only be called by the minter. Also\n     *         updates the mapping to lookup loan IDs by note IDs.\n     *\n     * @dev See {ERC721-_mint}.\n     *\n     * @param to                    The owner of the minted token.\n     * @param loanId                The ID of the token to mint, should match a loan.\n     *\n     * @return tokenId              The newly minted token ID.\n     */\n    function mint(address to, uint256 loanId) external override returns (uint256) {\n        if (!hasRole(ADMIN_ROLE, _msgSender())) revert PN_MintingRole(_msgSender());\n        _mint(to, loanId);\n\n        return loanId;\n    }\n\n    /**\n     * @notice Create a new token and assign it to a specified owner. The token ID\n     *         should match a loan ID, and can only be called by a burner - in practice\n     *         LoanCore, which burns notes when a loan ends. Also unserts the mapping to\n     *         lookup loan IDs by note IDs.\n     *\n     * @dev See {ERC721-_burn}.\n     *\n     * @param tokenId               The ID of the token to burn, should match a loan.\n     */\n    function burn(uint256 tokenId) external override {\n        if (!hasRole(ADMIN_ROLE, _msgSender())) revert PN_BurningRole(_msgSender());\n        _burn(tokenId);\n    }\n\n    /**\n     * @notice Pauses transfers on the note. This essentially blocks all loan lifecycle\n     *         operations, since all originations and transfers require transfers of\n     *         the note.\n     *\n     * @param paused                Whether the contract should be paused.\n     */\n    function setPaused(bool paused) external override onlyRole(ADMIN_ROLE) {\n        if (paused) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ===================================== ERC721 UTILITIES ===========================================\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC721, ERC721Enumerable, IERC165)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer.\n     *      This notifies the promissory note about the ownership transfer.\n     *\n     * @dev Does not let tokens be transferred when contract is paused.\n     *\n     * @param from                  The previous owner of the token.\n     * @param to                    The owner of the token after transfer.\n     * @param tokenId               The token ID.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n        if (paused()) revert PN_ContractPaused();\n\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC721Pausable is ERC721, Pausable {\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n"
    },
    "contracts/interfaces/ILoanCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"../libraries/LoanLibrary.sol\";\n\nimport \"./IPromissoryNote.sol\";\nimport \"./IFeeController.sol\";\nimport \"./ILoanCore.sol\";\n\ninterface ILoanCore {\n    // ================ Events =================\n\n    event LoanCreated(LoanLibrary.LoanTerms terms, uint256 loanId);\n    event LoanStarted(uint256 loanId, address lender, address borrower);\n    event LoanRepaid(uint256 loanId);\n    event LoanRolledOver(uint256 oldLoanId, uint256 newLoanId);\n    event InstallmentPaymentReceived(uint256 loanId, uint256 repaidAmount, uint256 remBalance);\n    event LoanClaimed(uint256 loanId);\n    event FeesClaimed(address token, address to, uint256 amount);\n    event SetFeeController(address feeController);\n    event NonceUsed(address indexed user, uint160 nonce);\n\n    // ============== Lifecycle Operations ==============\n\n    function startLoan(\n        address lender,\n        address borrower,\n        LoanLibrary.LoanTerms calldata terms\n    ) external returns (uint256 loanId);\n\n    function repay(uint256 loanId) external;\n\n    function repayPart(\n        uint256 _loanId,\n        uint256 _currentMissedPayments,\n        uint256 _paymentToPrincipal,\n        uint256 _paymentToInterest,\n        uint256 _paymentToLateFees\n    ) external;\n\n    function claim(uint256 loanId, uint256 currentInstallmentPeriod) external;\n\n    function rollover(\n        uint256 oldLoanId,\n        address borrower,\n        address lender,\n        LoanLibrary.LoanTerms calldata terms,\n        uint256 _settledAmount,\n        uint256 _amountToOldLender,\n        uint256 _amountToLender,\n        uint256 _amountToBorrower\n    ) external returns (uint256 newLoanId);\n\n    // ============== Nonce Management ==============\n\n    function consumeNonce(address user, uint160 nonce) external;\n\n    function cancelNonce(uint160 nonce) external;\n\n    // ============== View Functions ==============\n\n    function getLoan(uint256 loanId) external view returns (LoanLibrary.LoanData calldata loanData);\n\n    function isNonceUsed(address user, uint160 nonce) external view returns (bool);\n\n    function borrowerNote() external returns (IPromissoryNote);\n\n    function lenderNote() external returns (IPromissoryNote);\n\n    function feeController() external returns (IFeeController);\n}\n"
    },
    "contracts/interfaces/IPromissoryNote.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IPromissoryNote is IERC721Enumerable {\n    // ============== Token Operations ==============\n\n    function mint(address to, uint256 loanId) external returns (uint256);\n\n    function burn(uint256 tokenId) external;\n\n    function setPaused(bool paused) external;\n\n    // ============== Initializer ==============\n\n    function initialize(address loanCore) external;\n}\n"
    },
    "contracts/errors/Lending.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../libraries/LoanLibrary.sol\";\n\n/**\n * @title LendingErrors\n * @author Non-Fungible Technologies, Inc.\n *\n * This file contains custom errors for the core lending protocol contracts, with errors\n * prefixed by the contract that throws them (e.g., \"OC_\" for OriginationController).\n * Errors located in one place to make it possible to holistically look at all\n * protocol failure cases.\n */\n\n// ==================================== ORIGINATION CONTROLLER ======================================\n/// @notice All errors prefixed with OC_, to separate from other contracts in the protocol.\n\n/// @notice Zero address passed in where not allowed.\nerror OC_ZeroAddress();\n\n/**\n * @notice Ensure valid loan state for loan lifceycle operations.\n *\n * @param state                         Current state of a loan according to LoanState enum.\n */\nerror OC_InvalidState(LoanLibrary.LoanState state);\n\n/**\n * @notice Loan duration must be greater than 1hr and less than 3yrs.\n *\n * @param durationSecs                 Total amount of time in seconds.\n */\nerror OC_LoanDuration(uint256 durationSecs);\n\n/**\n * @notice Interest must be greater than 0.01%. (interestRate / 1e18 >= 1)\n *\n * @param interestRate                  InterestRate with 1e18 multiplier.\n */\nerror OC_InterestRate(uint256 interestRate);\n\n/**\n * @notice Loan terms must have even number of installments and intallment periods must be < 1000000.\n *\n * @param numInstallments               Number of installment periods in loan.\n */\nerror OC_NumberInstallments(uint256 numInstallments);\n\n/**\n * @notice One of the predicates for item verification failed.\n *\n * @param verifier                      The address of the verifier contract.\n * @param data                          The verification data (to be parsed by verifier).\n * @param vault                         The user's vault subject to verification.\n */\nerror OC_PredicateFailed(address verifier, bytes data, address vault);\n\n/**\n * @notice A caller attempted to approve themselves.\n *\n * @param caller                        The caller of the approve function.\n */\nerror OC_SelfApprove(address caller);\n\n/**\n * @notice A caller attempted to originate a loan with their own signature.\n *\n * @param caller                        The caller of the approve function, who was also the signer.\n */\nerror OC_ApprovedOwnLoan(address caller);\n\n/**\n * @notice The signature could not be recovered to the counterparty or approved party.\n *\n * @param target                        The target party of the signature, which should either be the signer,\n *                                      or someone who has approved the signer.\n * @param signer                        The signer determined from ECDSA.recover.\n */\nerror OC_InvalidSignature(address target, address signer);\n\n/**\n * @notice The verifier contract specified in a predicate has not been whitelisted.\n *\n * @param verifier                      The verifier the caller attempted to use.\n */\nerror OC_InvalidVerifier(address verifier);\n\n/**\n * @notice The function caller was neither borrower or lender, and was not approved by either.\n *\n * @param caller                        The unapproved function caller.\n */\nerror OC_CallerNotParticipant(address caller);\n\n/**\n * @notice Two related parameters for batch operations did not match in length.\n */\nerror OC_BatchLengthMismatch();\n\n/**\n * @notice Principal must be greater than 9999 Wei.\n *\n * @param principal                     Principal in ether.\n */\nerror OC_PrincipalTooLow(uint256 principal);\n\n/**\n * @notice Signature must not be expired.\n *\n * @param deadline                      Deadline in seconds.\n */\nerror OC_SignatureIsExpired(uint256 deadline);\n\n/**\n * @notice New currency does not match for a loan rollover request.\n *\n * @param oldCurrency                   The currency of the active loan.\n * @param newCurrency                   The currency of the new loan.\n */\nerror OC_RolloverCurrencyMismatch(address oldCurrency, address newCurrency);\n\n/**\n * @notice New currency does not match for a loan rollover request.\n *\n * @param oldCollateralAddress          The address of the active loan's collateral.\n * @param newCollateralAddress          The token ID of the active loan's collateral.\n * @param oldCollateralId               The address of the new loan's collateral.\n * @param newCollateralId               The token ID of the new loan's collateral.\n */\nerror OC_RolloverCollateralMismatch(\n    address oldCollateralAddress,\n    uint256 oldCollateralId,\n    address newCollateralAddress,\n    uint256 newCollateralId\n);\n\n// ==================================== ITEMS VERIFIER ======================================\n/// @notice All errors prefixed with IV_, to separate from other contracts in the protocol.\n\n/**\n * @notice Provided SignatureItem is missing an address.\n */\nerror IV_ItemMissingAddress();\n\n/**\n * @notice Provided SignatureItem has an invalid collateral type.\n * @dev    Should never actually fire, since cType is defined by an enum, so will fail on decode.\n *\n * @param asset                        The NFT contract being checked.\n * @param cType                        The collateralTytpe provided.\n */\nerror IV_InvalidCollateralType(address asset, uint256 cType);\n\n/**\n * @notice Provided ERC1155 signature item is requiring a non-positive amount.\n *\n * @param asset                         The NFT contract being checked.\n * @param amount                        The amount provided (should be 0).\n */\nerror IV_NonPositiveAmount1155(address asset, uint256 amount);\n\n/**\n * @notice Provided ERC1155 signature item is requiring an invalid token ID.\n *\n * @param asset                         The NFT contract being checked.\n * @param tokenId                       The token ID provided.\n */\nerror IV_InvalidTokenId1155(address asset, int256 tokenId);\n\n/**\n * @notice Provided ERC20 signature item is requiring a non-positive amount.\n *\n * @param asset                         The NFT contract being checked.\n * @param amount                        The amount provided (should be 0).\n */\nerror IV_NonPositiveAmount20(address asset, uint256 amount);\n\n// ==================================== REPAYMENT CONTROLLER ======================================\n/// @notice All errors prefixed with RC_, to separate from other contracts in the protocol.\n\n/**\n * @notice Could not dereference loan from loan ID.\n *\n * @param target                     The loanId being checked.\n */\nerror RC_CannotDereference(uint256 target);\n\n/**\n * @notice Repayment has already been completed for this loan without installments.\n */\nerror RC_NoPaymentDue();\n\n/**\n * @notice Caller is not the owner of lender note.\n *\n * @param caller                     Msg.sender of the function call.\n */\nerror RC_OnlyLender(address caller);\n\n/**\n * @notice Loan has not started yet.\n *\n * @param startDate                 block timestamp of the startDate of loan stored in LoanData.\n */\nerror RC_BeforeStartDate(uint256 startDate);\n\n/**\n * @notice Loan terms do not have any installments, use repay for repayments.\n *\n * @param numInstallments           Number of installments returned from LoanTerms.\n */\nerror RC_NoInstallments(uint256 numInstallments);\n\n/**\n * @notice Loan terms have installments, use repaypart or repayPartMinimum for repayments.\n *\n * @param numInstallments           Number of installments returned from LoanTerms.\n */\nerror RC_HasInstallments(uint256 numInstallments);\n\n/**\n * @notice No interest payment or late fees due.\n *\n * @param amount                    Minimum interest plus late fee amount returned\n *                                  from minimum payment calculation.\n */\nerror RC_NoMinPaymentDue(uint256 amount);\n\n/**\n * @notice Repaid amount must be larger than zero.\n */\nerror RC_RepayPartZero();\n\n/**\n * @notice Amount paramater less than the minimum amount due.\n *\n * @param amount                    Amount function call parameter.\n * @param minAmount                 The minimum amount due.\n */\nerror RC_RepayPartLTMin(uint256 amount, uint256 minAmount);\n\n// ==================================== Loan Core ======================================\n/// @notice All errors prefixed with LC_, to separate from other contracts in the protocol.\n\n/// @notice Zero address passed in where not allowed.\nerror LC_ZeroAddress();\n\n/**\n * @notice Check collateral is not already used in a active loan.\n *\n * @param collateralAddress             Address of the collateral.\n * @param collateralId                  ID of the collateral token.\n */\nerror LC_CollateralInUse(address collateralAddress, uint256 collateralId);\n\n/**\n * @notice Collateral is not in use for an attempted rollover.\n */\nerror LC_CollateralNotInUse();\n\n/**\n * @notice Ensure valid loan state for loan lifceycle operations.\n *\n * @param state                         Current state of a loan according to LoanState enum.\n */\nerror LC_InvalidState(LoanLibrary.LoanState state);\n\n/**\n * @notice Loan duration has not expired.\n *\n * @param dueDate                       Timestamp of the end of the loan duration.\n */\nerror LC_NotExpired(uint256 dueDate);\n\n/**\n * @notice Loan duration has not expired.\n *\n * @param returnAmount                  Total amount due for entire loan repayment.\n */\nerror LC_BalanceGTZero(uint256 returnAmount);\n\n/**\n * @notice Loan duration has not expired.\n *\n * @param user                          Address of collateral owner.\n * @param nonce                         Represents the number of transactions sent by address.\n */\nerror LC_NonceUsed(address user, uint160 nonce);\n\n/**\n * @notice Installment loan has not defaulted.\n */\nerror LC_LoanNotDefaulted();\n\n// ================================== Full Insterest Amount Calc ====================================\n/// @notice All errors prefixed with FIAC_, to separate from other contracts in the protocol.\n\n/**\n * @notice Interest must be greater than 0.01%. (interestRate / 1e18 >= 1)\n *\n * @param interestRate                  InterestRate with 1e18 multiplier.\n */\nerror FIAC_InterestRate(uint256 interestRate);\n\n// ==================================== Promissory Note ======================================\n/// @notice All errors prefixed with PN_, to separate from other contracts in the protocol.\n\n/**\n * @notice Deployer is allowed to initialize roles. Caller is not deployer.\n */\nerror PN_CannotInitialize();\n\n/**\n * @notice Roles have been initialized.\n */\nerror PN_AlreadyInitialized();\n\n/**\n * @notice Caller of mint function must have the MINTER_ROLE in AccessControl.\n *\n * @param caller                        Address of the function caller.\n */\nerror PN_MintingRole(address caller);\n\n/**\n * @notice Caller of burn function must have the BURNER_ROLE in AccessControl.\n *\n * @param caller                        Address of the function caller.\n */\nerror PN_BurningRole(address caller);\n\n/**\n * @notice No token transfers while contract is in paused state.\n */\nerror PN_ContractPaused();\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/interfaces/IFeeController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IFeeController {\n    // ================ Events =================\n\n    event UpdateOriginationFee(uint256 _newFee);\n    event UpdateRolloverFee(uint256 _newFee);\n\n    // ================ Fee Setters =================\n\n    function setOriginationFee(uint256 _originationFee) external;\n\n    function setRolloverFee(uint256 _rolloverFee) external;\n\n    // ================ Fee Getters =================\n\n    function getOriginationFee() external view returns (uint256);\n\n    function getRolloverFee() external view returns (uint256);\n}\n"
    },
    "contracts/PunkRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./external/interfaces/IWrappedPunks.sol\";\nimport \"./external/interfaces/IPunks.sol\";\n\nimport { PR_NotOwner } from \"./errors/LendingUtils.sol\";\n\n/**\n * @title PunkRouter\n * @author Non-Fungible Technologies, Inc.\n *\n * Convenience contract that allows users with CryptoPunks to\n * automatically wrap and deposit their punk to an AssetVault.\n * Punks are wrapped using the Wrapped Cryptopunks ERC721 contract.\n */\ncontract PunkRouter is ERC721Holder, Ownable {\n    // ============================================ STATE ==============================================\n\n    IPunks public immutable punks;\n    address public immutable proxy;\n    IWrappedPunks public immutable wrappedPunks;\n\n    // ========================================== CONSTRUCTOR ===========================================\n\n    /**\n     * @dev Initializes the contract with the correct contract references.\n     *\n     * @param _wrappedPunks         The wrapped punks contract.\n     * @param _punks                The CryptoPUnks contract.\n     */\n    constructor(IWrappedPunks _wrappedPunks, IPunks _punks) {\n        punks = _punks;\n        wrappedPunks = _wrappedPunks;\n\n        wrappedPunks.registerProxy();\n        proxy = wrappedPunks.proxyInfo(address(this));\n    }\n\n    /**\n     * @notice Wrap and deposit an original cryptopunk into an asset vault.\n     *         For depositPUnk to work, msg.sender must own the punk, and the\n     *         punk must be offered for sale to the punk router address for\n     *         0 ETH.\n     *\n     * @param punkIndex             The index of the CryptoPunk to deposit (i.e. token ID).\n     * @param bundleId              The id of the asset vault to deposit into.\n     */\n    function depositPunk(uint256 punkIndex, uint256 bundleId) external {\n        IWrappedPunks _wrappedPunks = wrappedPunks;\n        address punkOwner = punks.punkIndexToAddress(punkIndex);\n        if (punkOwner != msg.sender) revert PR_NotOwner(msg.sender);\n\n        punks.buyPunk(punkIndex);\n        punks.transferPunk(proxy, punkIndex);\n\n        _wrappedPunks.mint(punkIndex);\n        _wrappedPunks.safeTransferFrom(address(this), address(uint160(bundleId)), punkIndex);\n    }\n\n    /**\n     * @notice Withdraw a crypto punk that is accidentally held by the PunkRouter contract.\n     *         Only used for emergencies and misuse of the PunkRouter, and requires trust\n     *         that the contract owner will honestly send the punk to its rightful owner.\n     *\n     * @param punkIndex             The index of the CryptoPunk to withdraw.\n     * @param to                    The address of the new owner.\n     */\n    function withdrawPunk(uint256 punkIndex, address to) external onlyOwner {\n        punks.transferPunk(to, punkIndex);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/external/interfaces/IWrappedPunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IWrappedPunks is IERC721 {\n    function mint(uint256 punkIndex) external;\n\n    function burn(uint256 punkIndex) external;\n\n    function registerProxy() external;\n\n    function proxyInfo(address user) external returns (address proxy);\n}\n"
    },
    "contracts/external/interfaces/IPunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IPunks {\n    function punkIndexToAddress(uint256 punkIndex) external view returns (address owner);\n\n    function buyPunk(uint256 punkIndex) external;\n\n    function transferPunk(address to, uint256 punkIndex) external;\n}\n"
    },
    "contracts/test/WrappedPunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"../external/interfaces/IPunks.sol\";\nimport \"./UserProxy.sol\";\n\ncontract WrappedPunk is ERC721 {\n    event ProxyRegistered(address user, address proxy);\n\n    // Instance of cryptopunk smart contract\n    IPunks private _punkContract;\n\n    // Mapping from user address to proxy address\n    mapping(address => address) private _proxies;\n\n    /**\n     * @dev Initializes the contract settings\n     */\n    constructor(address punkContract_) ERC721(\"Wrapped Cryptopunks\", \"WPUNKS\") {\n        _punkContract = IPunks(punkContract_);\n    }\n\n    /**\n     * @dev Gets address of cryptopunk smart contract\n     */\n    function punkContract() public view returns (address) {\n        return address(_punkContract);\n    }\n\n    /**\n     * @dev Registers proxy\n     */\n    function registerProxy() public {\n        address sender = _msgSender();\n\n        require(_proxies[sender] == address(0), \"PunkWrapper: caller has registered the proxy\");\n\n        address proxy = address(new UserProxy());\n\n        _proxies[sender] = proxy;\n\n        emit ProxyRegistered(sender, proxy);\n    }\n\n    /**\n     * @dev Gets proxy address\n     */\n    function proxyInfo(address user) public view returns (address) {\n        return _proxies[user];\n    }\n\n    /**\n     * @dev Mints a wrapped punk\n     */\n    function mint(uint256 punkIndex) public {\n        address sender = _msgSender();\n\n        UserProxy proxy = UserProxy(_proxies[sender]);\n\n        require(proxy.transfer(address(_punkContract), punkIndex), \"PunkWrapper: transfer fail\");\n\n        _mint(sender, punkIndex);\n    }\n\n    /**\n     * @dev Burns a specific wrapped punk\n     */\n    function burn(uint256 punkIndex) public {\n        address sender = _msgSender();\n\n        require(_isApprovedOrOwner(sender, punkIndex), \"PunkWrapper: caller is not owner nor approved\");\n\n        _burn(punkIndex);\n\n        // Transfers ownership of punk on original cryptopunk smart contract to caller\n        _punkContract.transferPunk(sender, punkIndex);\n    }\n}\n"
    },
    "contracts/test/UserProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ncontract UserProxy {\n    address private _owner;\n\n    /**\n     * @dev Initializes the contract settings\n     */\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    /**\n     * @dev Transfers punk to the smart contract owner\n     */\n    function transfer(address punkContract, uint256 punkIndex) external returns (bool) {\n        if (_owner != msg.sender) {\n            return false;\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool result, ) = punkContract.call(\n            abi.encodeWithSignature(\"transferPunk(address,uint256)\", _owner, punkIndex)\n        );\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/presets/ERC1155PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../extensions/ERC1155Burnable.sol\";\nimport \"../extensions/ERC1155Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC1155} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC1155PresetMinterPauser is Context, AccessControlEnumerable, ERC1155Burnable, ERC1155Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that\n     * deploys the contract.\n     */\n    constructor(string memory uri) ERC1155(uri) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\n     *\n     * See {ERC1155-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mint(to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\n     */\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC1155Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC1155Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC1155)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override(ERC1155, ERC1155Pausable) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][account] = accountBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../extensions/ERC721Enumerable.sol\";\nimport \"../extensions/ERC721Burnable.sol\";\nimport \"../extensions/ERC721Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC721PresetMinterPauserAutoId is\n    Context,\n    AccessControlEnumerable,\n    ERC721Enumerable,\n    ERC721Burnable,\n    ERC721Pausable\n{\n    using Counters for Counters.Counter;\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    Counters.Counter private _tokenIdTracker;\n\n    string private _baseTokenURI;\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\n     * See {ERC721-tokenURI}.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) ERC721(name, symbol) {\n        _baseTokenURI = baseTokenURI;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    /**\n     * @dev Creates a new token for `to`. Its token ID will be automatically\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlEnumerable, ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/test/MockERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract MockERC721 is Context, ERC721Enumerable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdTracker;\n\n    /**\n     * @dev Initializes ERC721 token\n     */\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}\n\n    /**\n     * @dev Creates a new token for `to`. Public for any test to call.\n     *\n     * See {ERC721-_mint}.\n     */\n    function mint(address to) external returns (uint256 tokenId) {\n        tokenId = _tokenIdTracker.current();\n        _mint(to, uint256(uint160(address(this))) + tokenId);\n        _tokenIdTracker.increment();\n    }\n\n    /**\n     * @dev Burn the given token, can be called by anyone\n     */\n    function burn(uint256 tokenId) external {\n        _burn(tokenId);\n    }\n}\n\ncontract MockERC721Metadata is MockERC721 {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdTracker;\n\n    mapping(uint256 => string) public tokenURIs;\n\n    constructor(string memory name, string memory symbol) MockERC721(name, symbol) {}\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        return tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Creates a new token for `to`. Public for any test to call.\n     *\n     * See {ERC721-_mint}.\n     */\n    function mint(address to, string memory tokenUri) external returns (uint256 tokenId) {\n        tokenId = _tokenIdTracker.current();\n        _mint(to, tokenId);\n        _tokenIdTracker.increment();\n        _setTokenURI(tokenId, tokenUri);\n    }\n\n    function _setTokenURI(uint256 tokenId, string memory tokenUri) internal {\n        tokenURIs[tokenId] = tokenUri;\n    }\n}\n"
    },
    "contracts/verifiers/ItemsVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../interfaces/IVaultFactory.sol\";\nimport \"../interfaces/IAssetVault.sol\";\nimport \"../interfaces/ISignatureVerifier.sol\";\nimport \"../libraries/LoanLibrary.sol\";\n\nimport { IV_ItemMissingAddress, IV_InvalidCollateralType, IV_NonPositiveAmount1155, IV_InvalidTokenId1155, IV_NonPositiveAmount20 } from \"../errors/Lending.sol\";\n\n/**\n * @title ArcadeItemsVerifier\n * @author Non-Fungible Technologies, Inc.\n *\n * This contract can be used for verifying complex signature-encoded\n * bundle descriptions. This resolves on a new array of SignatureItems[],\n * which outside of verification, is passed around as bytes memory.\n *\n * Each SignatureItem has four fields:\n *      - cType (collateral Type)\n *      - asset (contract address of the asset)\n *      - tokenId (token ID of the asset, if applicable)\n *      - amount (amount of the asset, if applicable)\n *\n * - For token ids part of ERC721, other features beyond direct tokenIds are supported:\n *      - A provided token id of -1 is a wildcard, meaning any token ID is accepted.\n *      - Wildcard token ids are not supported for ERC1155.\n * - All amounts are taken as minimums. For instance, if the \"amount\" field of an ERC1155 is 5,\n *      then a bundle with 8 of those ERC1155s are accepted.\n * - For an ERC20 cType, tokenId is ignored. For an ERC721 cType, amount is ignored.\n *\n * - Any deviation from the above rules represents an unparseable signature and will always\n *      return invalid.\n *\n * - All multi-item signatures assume AND - any optional expressed by OR\n *      can be implemented by simply signing multiple separate signatures.\n */\ncontract ArcadeItemsVerifier is IArcadeSignatureVerifier {\n    using SafeCast for int256;\n\n    /// @dev Enum describing the collateral type of a signature item\n    enum CollateralType {\n        ERC_721,\n        ERC_1155,\n        ERC_20\n    }\n\n    /// @dev Enum describing each item that should be validated\n    struct SignatureItem {\n        // The type of collateral - which interface does it implement\n        CollateralType cType;\n        // The address of the collateral contract\n        address asset;\n        // The token ID of the collateral (only applicable to 721 and 1155)\n        // int256 because a negative value serves as wildcard\n        int256 tokenId;\n        // The minimum amount of collateral (only applicable for 20 and 1155)\n        uint256 amount;\n    }\n\n    // ==================================== COLLATERAL VERIFICATION =====================================\n\n    /**\n     * @notice Verify that the items specified by the packed SignatureItem array are held by the vault.\n     * @dev    Reverts on a malformed SignatureItem, returns false on missing contents.\n     *\n     * @param predicates                    The SignatureItem[] array of items, packed in bytes.\n     * @param vault                         The vault that should own the specified items.\n     *\n     * @return verified                     Whether the bundle contains the specified items.\n     */\n    // solhint-disable-next-line code-complexity\n    function verifyPredicates(bytes calldata predicates, address vault) external view override returns (bool) {\n        // Unpack items\n        SignatureItem[] memory items = abi.decode(predicates, (SignatureItem[]));\n\n        for (uint256 i = 0; i < items.length; i++) {\n            SignatureItem memory item = items[i];\n\n            // No asset provided\n            if (item.asset == address(0)) revert IV_ItemMissingAddress();\n\n            if (item.cType == CollateralType.ERC_721) {\n                IERC721 asset = IERC721(item.asset);\n                int256 id = item.tokenId;\n\n                // Wildcard, but vault has no assets\n                if (id < 0 && asset.balanceOf(vault) == 0) return false;\n                // Does not own specifically specified asset\n                else if (id >= 0 && asset.ownerOf(id.toUint256()) != vault) return false;\n            } else if (item.cType == CollateralType.ERC_1155) {\n                IERC1155 asset = IERC1155(item.asset);\n\n                int256 id = item.tokenId;\n                uint256 amt = item.amount;\n\n                // Cannot require 0 amount\n                if (amt == 0) revert IV_NonPositiveAmount1155(item.asset, amt);\n\n                // Wildcard not allowed for 1155\n                if (id < 0) revert IV_InvalidTokenId1155(item.asset, id);\n\n                // Does not own specifically specified asset\n                if (asset.balanceOf(vault, id.toUint256()) < amt) return false;\n            } else if (item.cType == CollateralType.ERC_20) {\n                IERC20 asset = IERC20(item.asset);\n\n                uint256 amt = item.amount;\n\n                // Cannot require 0 amount\n                if (amt == 0) revert IV_NonPositiveAmount20(item.asset, amt);\n\n                // Does not own specifically specified asset\n                if (asset.balanceOf(vault) < amt) return false;\n            } else {\n                // Interface could not be parsed - fail\n                revert IV_InvalidCollateralType(item.asset, uint256(item.cType));\n            }\n        }\n\n        // Loop completed - all items found\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/interfaces/IVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IVaultFactory {\n    // ============= Events ==============\n\n    event VaultCreated(address vault, address to);\n\n    // ================ View Functions ================\n\n    function isInstance(address instance) external view returns (bool validity);\n\n    function instanceCount() external view returns (uint256);\n\n    function instanceAt(uint256 tokenId) external view returns (address);\n\n    function instanceAtIndex(uint256 index) external view returns (address);\n\n    // ================ Factory Operations ================\n\n    function initializeBundle(address to) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAssetVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./ICallWhitelist.sol\";\n\ninterface IAssetVault {\n    // ============= Events ==============\n\n    event WithdrawEnabled(address operator);\n    event WithdrawERC20(address indexed operator, address indexed token, address recipient, uint256 amount);\n    event WithdrawERC721(address indexed operator, address indexed token, address recipient, uint256 tokenId);\n\n    event WithdrawERC1155(\n        address indexed operator,\n        address indexed token,\n        address recipient,\n        uint256 tokenId,\n        uint256 amount\n    );\n\n    event WithdrawETH(address indexed operator, address indexed recipient, uint256 amount);\n    event Call(address indexed operator, address indexed to, bytes data);\n\n    // ================= Initializer ==================\n\n    function initialize(address _whitelist) external;\n\n    // ================ View Functions ================\n\n    function withdrawEnabled() external view returns (bool);\n\n    function whitelist() external view returns (ICallWhitelist);\n\n    // ================ Withdrawal Operations ================\n\n    function enableWithdraw() external;\n\n    function withdrawERC20(address token, address to) external;\n\n    function withdrawERC721(\n        address token,\n        uint256 tokenId,\n        address to\n    ) external;\n\n    function withdrawERC1155(\n        address token,\n        uint256 tokenId,\n        address to\n    ) external;\n\n    function withdrawETH(address to) external;\n\n    // ================ Utility Operations ================\n\n    function call(address to, bytes memory data) external;\n}\n"
    },
    "contracts/interfaces/ISignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../libraries/LoanLibrary.sol\";\n\ninterface IArcadeSignatureVerifier {\n    // ============== Collateral Verification ==============\n\n    function verifyPredicates(bytes calldata predicates, address vault) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ICallWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface ICallWhitelist {\n    // ============= Events ==============\n\n    event CallAdded(address operator, address callee, bytes4 selector);\n    event CallRemoved(address operator, address callee, bytes4 selector);\n\n    // ================ View Functions ================\n\n    function isWhitelisted(address callee, bytes4 selector) external view returns (bool);\n\n    function isBlacklisted(bytes4 selector) external view returns (bool);\n\n    // ================ Update Operations ================\n\n    function add(address callee, bytes4 selector) external;\n\n    function remove(address callee, bytes4 selector) external;\n}\n"
    },
    "contracts/RepaymentController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/** V2 Notes\n * Interest input as a rate/ percent value.\n *\n * _calcAmountsDue - function which returns the current balanceDue(uint256),\n * defaulted(bool), and payableCurrency(address)\n *\n * repayPartMinimum - function for repaying installment payments. The minimum amount payable.\n * Interest and any fees only.\n *\n * repayPart - function for repaying installment payments. The amount must be higher than\n * the minimum amount payable.\n */\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./InstallmentsCalc.sol\";\nimport \"./libraries/LoanLibrary.sol\";\nimport \"./interfaces/IPromissoryNote.sol\";\nimport \"./interfaces/ILoanCore.sol\";\nimport \"./interfaces/IRepaymentController.sol\";\n\nimport { RC_CannotDereference, RC_NoPaymentDue, RC_OnlyLender, RC_BeforeStartDate, RC_NoInstallments, RC_NoMinPaymentDue, RC_RepayPartZero, RC_RepayPartLTMin, RC_HasInstallments } from \"./errors/Lending.sol\";\n\n/**\n * @title RepaymentController\n * @author Non-Fungible Technologies, Inc.\n *\n * The Repayment Controller is the entry point for all loan lifecycle\n * operations in the Arcade.xyz lending protocol once a loan has begun.\n * This contract allows a caller to calculate an amount due on a loan,\n * make a payment (either in full or part, for installment loans), and\n * claim collateral on a defaulted loan. It is this contract's responsibility\n * to verify loan conditions before calling LoanCore.\n */\ncontract RepaymentController is IRepaymentController, InstallmentsCalc, AccessControl {\n    using SafeERC20 for IERC20;\n\n    // ============================================ STATE ===============================================\n\n    ILoanCore private loanCore;\n    IPromissoryNote private borrowerNote;\n    IPromissoryNote private lenderNote;\n\n    // Installment parameters\n    // * * * NOTE!!! Finish implementation of grace period\n    uint256 public constant GRACE_PERIOD = 604800; // 60*60*24*7 // 1 week\n\n    constructor(\n        ILoanCore _loanCore,\n        IPromissoryNote _borrowerNote,\n        IPromissoryNote _lenderNote\n    ) {\n        loanCore = _loanCore;\n        borrowerNote = _borrowerNote;\n        lenderNote = _lenderNote;\n    }\n\n    // ==================================== LIFECYCLE OPERATIONS ========================================\n\n    /**\n     * @notice Repay an active loan, referenced by borrower note ID (equivalent to loan ID). The interest for a loan\n     *         is calculated, and the principal plus interest is withdrawn from the borrower.\n     *         Control is passed to LoanCore to complete repayment.\n     *\n     * @param  loanId               The ID of the loan.\n     */\n    function repay(uint256 loanId) external override {\n        LoanLibrary.LoanTerms memory terms = loanCore.getLoan(loanId).terms;\n        if (terms.durationSecs == 0) revert RC_CannotDereference(loanId);\n\n        //cannot use for installment loans, call repayPart or repayPartMinimum\n        if (terms.numInstallments != 0) revert RC_HasInstallments(terms.numInstallments);\n\n        // withdraw principal plus interest from borrower and send to loan core\n        uint256 total = getFullInterestAmount(terms.principal, terms.interestRate);\n        if (total == 0) revert RC_NoPaymentDue();\n\n        IERC20(terms.payableCurrency).safeTransferFrom(_msgSender(), address(this), total);\n        IERC20(terms.payableCurrency).approve(address(loanCore), total);\n\n        // call repay function in loan core\n        loanCore.repay(loanId);\n    }\n\n    /**\n     * @notice Claim collateral an active loan, referenced by lender note ID (equivalent to loan ID). The loan\n     *         must be passed the due date, or, in the case of an installment, the amount\n     *         overdue must be beyond the liquidation threshold. No funds are collected\n     *         from the borrower.\n     *\n     * @param  loanId               The ID of the loan.\n     */\n    function claim(uint256 loanId) external override {\n        // make sure that caller owns lender note\n        address lender = lenderNote.ownerOf(loanId);\n        if (lender != msg.sender) revert RC_OnlyLender(msg.sender);\n        // get LoanData for determining how to send the current installment parameter to LoanCore\n        LoanLibrary.LoanData memory data = loanCore.getLoan(loanId);\n        if (data.terms.numInstallments > 0) {\n            // get the current installment period\n            uint256 _installmentPeriod = currentInstallmentPeriod(\n                data.startDate,\n                data.terms.durationSecs,\n                data.terms.numInstallments\n            );\n            // call claim function in loan core\n            loanCore.claim(loanId, _installmentPeriod);\n        } else {\n            // call claim function in loan core indicating a legacy loan type with 0 as the installment period\n            // installment loans cannot have an installment period of 0\n            loanCore.claim(loanId, 0);\n        }\n    }\n\n    // =========================== INSTALLMENT SPECIFIC OPERATIONS ===============================\n\n    /**\n     * @notice Call _calcAmountsDue publicly to determine the amount of the payable currency\n     *         must be approved for the payment. Returns minimum balance due, late fees, and number\n     *         of missed payments.\n     *\n     * @dev Calls _calcAmountsDue similar to repayPart and repayPartMinimum, but does not call LoanCore.\n     *\n     * @param loanId                            LoanId, used to locate terms.\n     *\n     * @return minInterestDue                   The amount of interest due, compounded over missed payments.\n     * @return lateFees                         The amount of late fees due, compounded over missed payments.\n     * @return _installmentsMissed              The number of overdue installment periods since the last payment.\n     */\n    function getInstallmentMinPayment(uint256 loanId)\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // load terms from loanId\n        LoanLibrary.LoanData memory data = loanCore.getLoan(loanId);\n        // get loan from borrower note\n        if (data.state == LoanLibrary.LoanState.DUMMY_DO_NOT_USE) revert RC_CannotDereference(loanId);\n\n        uint256 installments = data.terms.numInstallments;\n        if (installments == 0) revert RC_NoInstallments(installments);\n\n        // get the current minimum balance due for the installment\n        (uint256 minInterestDue, uint256 lateFees, uint256 numMissedPayments) = _calcAmountsDue(\n            data.balance,\n            data.startDate,\n            data.terms.durationSecs,\n            installments,\n            data.numInstallmentsPaid,\n            data.terms.interestRate\n        );\n\n        return (minInterestDue, lateFees, numMissedPayments);\n    }\n\n    /**\n     * @notice Called when paying back installment loan with the minimum amount due.\n     *         Do not call for single payment loan types. Calling this function does not\n     *         reduce the loans principal.\n     *\n     * @dev Only pay off the current interest amount and, if applicable, any late fees accrued.\n     *\n     * @param loanId                            LoanId, used to locate terms.\n     */\n    function repayPartMinimum(uint256 loanId) external override {\n        // get current minimum balance due for the installment repayment, based on specific loanId.\n        (uint256 minBalanceDue, uint256 lateFees, uint256 numMissedPayments) = getInstallmentMinPayment(loanId);\n        // total amount due, interest amount plus any late fees\n        uint256 _minAmount = minBalanceDue + lateFees;\n        // cannot call repayPartMinimum twice in the same installment period\n        if (_minAmount == 0) revert RC_NoPaymentDue();\n\n        // load terms from loanId\n        LoanLibrary.LoanData memory data = loanCore.getLoan(loanId);\n        // gather minimum payment from _msgSender()\n        IERC20(data.terms.payableCurrency).safeTransferFrom(_msgSender(), address(this), _minAmount);\n        // approve loanCore to take minBalanceDue\n        IERC20(data.terms.payableCurrency).approve(address(loanCore), _minAmount);\n        // call repayPart function in loanCore\n        loanCore.repayPart(loanId, numMissedPayments, 0, minBalanceDue, lateFees);\n    }\n\n    /**\n     * @notice Called when paying back installment loan with an amount greater than the minimum amount due.\n     *         Do not call for single payment loan types.\n     *\n     * @dev Pay off the current interest and, if applicable any late fees accrued, and an additional\n     *      amount to be deducted from the loan principal.\n     *\n     * @param loanId                            LoanId, used to locate terms.\n     * @param amount                            Amount = minBalDue + lateFees + amountToPayOffPrincipal\n     *                                          value must be greater than minBalDue + latefees returned\n     *                                          from getInstallmentMinPayment function call.\n     */\n    function repayPart(uint256 loanId, uint256 amount) external override {\n        if (amount == 0) revert RC_RepayPartZero();\n\n        // get current minimum balance due for the installment repayment, based on specific loanId.\n        (uint256 minBalanceDue, uint256 lateFees, uint256 numMissedPayments) = getInstallmentMinPayment(loanId);\n        // total minimum amount due, interest amount plus any late fees\n        uint256 _minAmount = minBalanceDue + lateFees;\n        // require amount taken from the _msgSender() to be larger than or equal to minBalanceDue\n        if (amount < _minAmount) revert RC_RepayPartLTMin(amount, _minAmount);\n        // load data from loanId\n        LoanLibrary.LoanData memory data = loanCore.getLoan(loanId);\n        // calculate the payment to principal after subtracting (minBalanceDue + lateFees)\n        uint256 _totalPaymentToPrincipal = amount - (_minAmount);\n        // gather amount specified in function call params from _msgSender()\n        IERC20(data.terms.payableCurrency).safeTransferFrom(_msgSender(), address(this), amount);\n        // approve loanCore to take amount\n        IERC20(data.terms.payableCurrency).approve(address(loanCore), amount);\n        // call repayPart function in loanCore\n        loanCore.repayPart(loanId, numMissedPayments, _totalPaymentToPrincipal, minBalanceDue, lateFees);\n    }\n\n    /**\n     * @notice Called when the user wants to close an installment loan without neededing to deteremine the\n     *         amount to pass to the repayPart function. This is done by paying the remaining principal\n     *         and any interest or late fees due.\n     *\n     * @dev Pay off the current interest and, if applicable any late fees accrued, and the remaining principal\n     *      left on the loan.\n     *\n     * @param loanId                            LoanId, used to locate terms.\n     */\n    function closeLoan(uint256 loanId) external override {\n        // get current minimum balance due for the installment repayment, based on specific loanId.\n        (uint256 minBalanceDue, uint256 lateFees, uint256 numMissedPayments) = getInstallmentMinPayment(loanId);\n        // load data from loanId\n        LoanLibrary.LoanData memory data = loanCore.getLoan(loanId);\n        // total amount to close loan (remaining balance + current interest + late fees)\n        uint256 _totalAmount = data.balance + minBalanceDue + lateFees;\n        // gather amount specified in function call params from _msgSender()\n        IERC20(data.terms.payableCurrency).safeTransferFrom(_msgSender(), address(this), _totalAmount);\n        // approve loanCore to take minBalanceDue\n        IERC20(data.terms.payableCurrency).approve(address(loanCore), _totalAmount);\n        // Call repayPart function in loanCore.\n        loanCore.repayPart(loanId, numMissedPayments, data.balance, minBalanceDue, lateFees);\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    /**\n     * @notice Called when the user wants to close an installment loan without needing to determine the\n     *         amount to pass to the repayPart function. This is done by paying the remaining principal\n     *         and any interest or late fees due.\n     *\n     * @dev Pay off the current interest and, if applicable any late fees accrued, in addition to any\n     *      remaining principal left on the loan.\n     *\n     * @param loanId                            LoanId, used to locate terms.\n     *\n     * @return amountDue                        The total amount due to close the loan, including principal, interest,\n     *                                          and late fees.\n     * @return numMissedPayments                The number of overdue installment periods since the last payment.\n     */\n    function amountToCloseLoan(uint256 loanId) external view override returns (uint256, uint256) {\n        // get current minimum balance due for the installment repayment, based on specific loanId.\n        (uint256 minBalanceDue, uint256 lateFees, uint256 numMissedPayments) = getInstallmentMinPayment(loanId);\n        // load data from loanId\n        LoanLibrary.LoanData memory data = loanCore.getLoan(loanId);\n\n        // the required total amount needed to close the loan (remaining balance + current interest + late fees)\n        return ((data.balance + minBalanceDue + lateFees), numMissedPayments);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/InstallmentsCalc.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./interfaces/IInstallmentsCalc.sol\";\n\nimport { FIAC_InterestRate } from \"./errors/Lending.sol\";\n\n/**\n * @title OriginationController\n * @author Non-Fungible Technologies, Inc.\n *\n * Interface for a calculating the interest amount\n * given an interest rate and principal amount. Assumes\n * that the interestRate is already expressed over the desired\n * time period.\n */\nabstract contract InstallmentsCalc is IInstallmentsCalc {\n    // ============================================ STATE ==============================================\n\n    /// @dev The units of precision equal to the minimum interest of 1 basis point.\n    uint256 public constant INTEREST_RATE_DENOMINATOR = 1e18;\n    /// @dev The denominator to express the final interest in terms of basis ponits.\n    uint256 public constant BASIS_POINTS_DENOMINATOR = 10_000;\n    // Interest rate parameter\n    uint256 public constant INSTALLMENT_PERIOD_MULTIPLIER = 1_000_000;\n    // 50 / BASIS_POINTS_DENOMINATOR = 0.5%\n    uint256 public constant LATE_FEE = 50;\n\n    // ======================================== CALCULATIONS ===========================================\n\n    /**\n     * @notice Calculate the interest due over a full term.\n     * @dev Interest and principal must be entered with 18 units of\n     *      precision from the basis point unit (e.g. 1e18 == 0.01%)\n     *\n     * @param principal                  Principal amount in the loan terms.\n     * @param interestRate               Interest rate in the loan terms.\n     *\n     * @return interest                  The amount of interest due.\n     */\n    function getFullInterestAmount(uint256 principal, uint256 interestRate) public pure virtual returns (uint256) {\n        // Interest rate to be greater than or equal to 0.01%\n        if (interestRate / INTEREST_RATE_DENOMINATOR < 1) revert FIAC_InterestRate(interestRate);\n\n        return principal + ((principal * (interestRate / INTEREST_RATE_DENOMINATOR)) / BASIS_POINTS_DENOMINATOR);\n    }\n\n    /**\n     * @notice Calculates and returns the current installment period relative to the loan's startDate,\n     *         durationSecs, and numInstallments. Using these three paremeters and the blocks current timestamp\n     *         we are able to determine the current timeframe relative to the total number of installments.\n     *\n     * @dev Get current installment using the startDate, duration, and current time.\n     *      NOTE!!! DurationSecs must be greater than 10 seconds (10%10 = 0).\n     *              Also verify the _timestampMultiplier value for what is determined on the max and min loan durations.\n     *\n     * @param startDate                    The start date of the loan as a timestamp.\n     * @param durationSecs                 The duration of the loan in seconds.\n     * @param numInstallments              The total number of installments in the loan terms.\n     */\n    function currentInstallmentPeriod(\n        uint256 startDate,\n        uint256 durationSecs,\n        uint256 numInstallments\n    ) internal view returns (uint256) {\n        // *** Local State\n        uint256 _currentTime = block.timestamp;\n        uint256 _installmentPeriod = 1; // can only be called after the loan has started\n        uint256 _relativeTimeInLoan = 0; // initial value\n        uint256 _timestampMultiplier = 1e20; // inital value\n\n        // *** Get Timestamp Mulitpier\n        for (uint256 i = 1e18; i >= 10; i = i / 10) {\n            if (durationSecs % i != durationSecs) {\n                if (_timestampMultiplier == 1e20) {\n                    _timestampMultiplier = (1e18 / i);\n                }\n            }\n        }\n\n        // *** Time Per Installment\n        uint256 _timePerInstallment = durationSecs / numInstallments;\n\n        // *** Relative Time In Loan\n        _relativeTimeInLoan = (_currentTime - startDate) * _timestampMultiplier;\n\n        // *** Check to see when _timePerInstallment * i is greater than _relativeTimeInLoan\n        // Used to determine the current installment period. (j+1 to account for the current period)\n        uint256 j = 1;\n        while ((_timePerInstallment * j) * _timestampMultiplier <= _relativeTimeInLoan) {\n            _installmentPeriod = j + 1;\n            j++;\n        }\n        // *** Return\n        return (_installmentPeriod);\n    }\n\n    /**\n     * @notice Calculates and returns the compounded fees and minimum balance for all the missed payments\n     *\n     * @dev Get minimum installment payment due, and any late fees accrued due to payment being late\n     *\n     * @param balance                           Current balance of the loan\n     * @param _interestRatePerInstallment       Interest rate per installment period\n     * @param _installmentsMissed               Number of missed installment periods\n     */\n    function _getFees(\n        uint256 balance,\n        uint256 _interestRatePerInstallment,\n        uint256 _installmentsMissed\n    ) internal pure returns (uint256, uint256) {\n        uint256 minInterestDue = 0; // initial state\n        uint256 currentBal = balance; // remaining principal\n        uint256 lateFees = 0; // initial state\n        // calculate the late fees based on number of installments missed\n        // late fees compound on any installment periods missed. For consecutive missed payments\n        // late fees of first installment missed are added to the principal of the next late fees calculation\n        for (uint256 i = 0; i < _installmentsMissed; i++) {\n            // interest due per period based on currentBal value\n            uint256 intDuePerPeriod = (((currentBal * _interestRatePerInstallment) / INSTALLMENT_PERIOD_MULTIPLIER) /\n                BASIS_POINTS_DENOMINATOR);\n            // update local state, next interest payment and late fee calculated off updated currentBal variable\n            minInterestDue += intDuePerPeriod;\n            lateFees += ((currentBal * LATE_FEE) / BASIS_POINTS_DENOMINATOR);\n            currentBal += intDuePerPeriod + lateFees;\n        }\n\n        // one additional interest period added to _installmentsMissed for the current payment being made.\n        // no late fees added to this payment. currentBal compounded.\n        minInterestDue +=\n            ((currentBal * _interestRatePerInstallment) / INSTALLMENT_PERIOD_MULTIPLIER) /\n            BASIS_POINTS_DENOMINATOR;\n\n        return (minInterestDue, lateFees);\n    }\n\n    /**\n     * @notice Calulates and returns the minimum interest balance on loan, current late fees,\n     *         and the current number of payments missed. If called twice in the same installment\n     *         period, will return all zeros the second call.\n     *\n     * @dev Get minimum installment payment due, any late fees accrued, and\n     *      the number of missed payments since last installment payment.\n     *\n     *      1. Calculate relative time values to determine the number of installment periods missed.\n     *      2. Is the repayment late based on the number of installment periods missed?\n     *          Y. Calculate minimum balance due with late fees.\n     *          N. Return only interest rate payment as minimum balance due.\n     *\n     * @param balance                           Current balance of the loan\n     * @param startDate                         Timestamp of the start of the loan duration\n     * @param durationSecs                      Duration of the loan in seconds\n     * @param numInstallments                   Total number of installments in the loan\n     * @param numInstallmentsPaid               Total number of installments paid, not including this current payment\n     * @param interestRate                      The total interest rate for the loans duration from the loan terms\n     */\n    function _calcAmountsDue(\n        uint256 balance,\n        uint256 startDate,\n        uint256 durationSecs,\n        uint256 numInstallments,\n        uint256 numInstallmentsPaid,\n        uint256 interestRate\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // *** Installment Time\n        uint256 _installmentPeriod = currentInstallmentPeriod(startDate, durationSecs, numInstallments);\n\n        // *** Time related to number of installments paid\n        if (numInstallmentsPaid >= _installmentPeriod) {\n            // When numInstallmentsPaid is greater than or equal to the _installmentPeriod\n            // this indicates that the minimum interest and any late fees for this installment period\n            // have alread been repaid. Any additional amount sent in this installment period goes to principal\n            return (0, 0, 0);\n        }\n\n        // +1 for current install payment\n        uint256 _installmentsMissed = _installmentPeriod - (numInstallmentsPaid + 1);\n\n        // ** Installment Interest - using mulitpier of 1 million.\n        // There should not be loan with more than 1 million installment periods. Checked in LoanCore.\n        uint256 _interestRatePerInstallment = ((interestRate / INTEREST_RATE_DENOMINATOR) *\n            INSTALLMENT_PERIOD_MULTIPLIER) / numInstallments;\n\n        // ** Determine if late fees are added and if so, how much?\n        // Calulate number of payments missed based on _latePayment, _pastDueDate\n\n        // * If payment on time...\n        if (_installmentsMissed == 0) {\n            // Minimum balance due calculation. Based on interest per installment period\n            uint256 minBalDue = ((balance * _interestRatePerInstallment) / INSTALLMENT_PERIOD_MULTIPLIER) /\n                BASIS_POINTS_DENOMINATOR;\n\n            return (minBalDue, 0, 0);\n        }\n        // * If payment is late, or past the loan duration...\n        else {\n            // get late fees based on number of payments missed and current principal due\n            (uint256 minInterestDue, uint256 lateFees) = _getFees(\n                balance,\n                _interestRatePerInstallment,\n                _installmentsMissed\n            );\n\n            return (minInterestDue, lateFees, _installmentsMissed);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IRepaymentController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IRepaymentController {\n    // ============== Lifeycle Operations ==============\n\n    function repay(uint256 loanId) external;\n\n    function claim(uint256 loanId) external;\n\n    function repayPartMinimum(uint256 loanId) external;\n\n    function repayPart(uint256 loanId, uint256 amount) external;\n\n    function closeLoan(uint256 loanId) external;\n\n    // ============== View Functions ==============\n\n    function getInstallmentMinPayment(uint256 loanId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function amountToCloseLoan(uint256 loanId) external returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IInstallmentsCalc.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IInstallmentsCalc {\n    // ================ View Functions ================\n\n    function getFullInterestAmount(uint256 principal, uint256 interestRate) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFlashRollover.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../external/interfaces/ILendingPool.sol\";\nimport \"./ILoanCore.sol\";\nimport \"./IOriginationController.sol\";\nimport \"./IRepaymentController.sol\";\n\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool);\n\n    // Function names defined by AAVE\n    /* solhint-disable func-name-mixedcase */\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function LENDING_POOL() external view returns (ILendingPool);\n    /* solhint-enable func-name-mixedcase */\n}\n\ninterface IFlashRollover is IFlashLoanReceiver {\n    event Rollover(address indexed lender, address indexed borrower, uint256 collateralTokenId, uint256 newLoanId);\n\n    event Migration(address indexed oldLoanCore, address indexed newLoanCore, uint256 newLoanId);\n\n    event SetOwner(address owner);\n\n    /**\n     * The contract references needed to roll\n     * over the loan. Other dependent contracts\n     * (asset wrapper, promissory notes) can\n     * be fetched from the relevant LoanCore\n     * contracts.\n     */\n    struct RolloverContractParams {\n        ILoanCore sourceLoanCore;\n        ILoanCore targetLoanCore;\n        IRepaymentController sourceRepaymentController;\n        IOriginationController targetOriginationController;\n    }\n\n    /**\n     * Holds parameters passed through flash loan\n     * control flow that dictate terms of the new loan.\n     * Contains a signature by lender for same terms.\n     * isLegacy determines which loanCore to look for the\n     * old loan in.\n     */\n    struct OperationData {\n        RolloverContractParams contracts;\n        uint256 loanId;\n        LoanLibrary.LoanTerms newLoanTerms;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /**\n     * Defines the contracts that should be used for a\n     * flash loan operation. May change based on if the\n     * old loan is on the current loanCore or legacy (in\n     * which case it requires migration).\n     */\n    struct OperationContracts {\n        ILoanCore loanCore;\n        IERC721 borrowerNote;\n        IERC721 lenderNote;\n        IFeeController feeController;\n        IERC721 assetWrapper;\n        IRepaymentController repaymentController;\n        IOriginationController originationController;\n        ILoanCore targetLoanCore;\n        IERC721 targetBorrowerNote;\n    }\n\n    function rolloverLoan(\n        RolloverContractParams calldata contracts,\n        uint256 loanId,\n        LoanLibrary.LoanTerms calldata newLoanTerms,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function setOwner(address _owner) external;\n\n    function flushToken(IERC20 token, address to) external;\n}\n"
    },
    "contracts/external/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity ^0.8.11;\n\n/* solhint-disable max-line-length */\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n}\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     **/\n    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external;\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOriginationController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../libraries/LoanLibrary.sol\";\n\ninterface IOriginationController {\n    // ================ Data Types =============\n\n    enum Side {\n        BORROW,\n        LEND\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct RolloverAmounts {\n        uint256 needFromBorrower;\n        uint256 leftoverPrincipal;\n        uint256 amountToOldLender;\n        uint256 amountToLender;\n        uint256 amountToBorrower;\n        uint256 fee;\n    }\n\n    // ================ Events =================\n\n    event Approval(address indexed owner, address indexed signer, bool isApproved);\n    event SetAllowedVerifier(address indexed verifier, bool isAllowed);\n\n    // ============== Origination Operations ==============\n\n    function initializeLoan(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce\n    ) external returns (uint256 loanId);\n\n    function initializeLoanWithItems(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce,\n        LoanLibrary.Predicate[] calldata itemPredicates\n    ) external returns (uint256 loanId);\n\n    function initializeLoanWithCollateralPermit(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce,\n        Signature calldata collateralSig,\n        uint256 permitDeadline\n    ) external returns (uint256 loanId);\n\n    function initializeLoanWithCollateralPermitAndItems(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce,\n        Signature calldata collateralSig,\n        uint256 permitDeadline,\n        LoanLibrary.Predicate[] calldata itemPredicates\n    ) external returns (uint256 loanId);\n\n    function rolloverLoan(\n        uint256 oldLoanId,\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce\n    ) external returns (uint256 newLoanId);\n\n    function rolloverLoanWithItems(\n        uint256 oldLoanId,\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce,\n        LoanLibrary.Predicate[] calldata itemPredicates\n    ) external returns (uint256 newLoanId);\n\n    // ================ Permission Management =================\n\n    function approve(address signer, bool approved) external;\n\n    function isApproved(address owner, address signer) external returns (bool);\n\n    function isSelfOrApproved(address target, address signer) external returns (bool);\n\n    function isApprovedForContract(\n        address target,\n        Signature calldata sig,\n        bytes32 sighash\n    ) external returns (bool);\n\n    // ============== Signature Verification ==============\n\n    function recoverTokenSignature(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        Signature calldata sig,\n        uint160 nonce,\n        Side side\n    ) external view returns (bytes32 sighash, address signer);\n\n    function recoverItemsSignature(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        Signature calldata sig,\n        uint160 nonce,\n        Side side,\n        bytes32 itemsHash\n    ) external view returns (bytes32 sighash, address signer);\n\n    // ============== Admin Operations ==============\n\n    function setAllowedVerifier(address verifier, bool isAllowed) external;\n\n    function setAllowedVerifierBatch(address[] calldata verifiers, bool[] calldata isAllowed) external;\n\n    function isAllowedVerifier(address verifier) external view returns (bool);\n}\n"
    },
    "contracts/test/MockLendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IFlashRollover.sol\";\n\n/* solhint-disable no-unused-vars */\ncontract MockAddressesProvider {\n    address public lendingPool;\n\n    constructor(address _lendingPool) {\n        lendingPool = _lendingPool;\n    }\n\n    function getLendingPool() external view returns (address) {\n        return lendingPool;\n    }\n}\n\ncontract MockLendingPool {\n    uint256 private loanFeeBps = 9;\n\n    event FlashLoan(uint256 amount, uint256 fee);\n\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata,\n        address,\n        bytes calldata params,\n        uint16\n    ) external {\n        uint256 premium = (amounts[0] * loanFeeBps) / 10_000;\n        uint256[] memory premiums = new uint256[](1);\n        premiums[0] = premium;\n\n        // Send assets - only supports one asset\n        IERC20(assets[0]).transfer(receiverAddress, amounts[0]);\n\n        // Call the callback operation\n        IFlashLoanReceiver(receiverAddress).executeOperation(assets, amounts, premiums, msg.sender, params);\n\n        emit FlashLoan(amounts[0], premium);\n        // Require repayment plus premium\n        require(\n            IERC20(assets[0]).transferFrom(receiverAddress, address(this), amounts[0] + premiums[0]),\n            \"Failed repayment\"\n        );\n    }\n}\n"
    },
    "contracts/vault/AssetVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/ICallWhitelist.sol\";\nimport \"../interfaces/ICallDelegator.sol\";\nimport \"../interfaces/IAssetVault.sol\";\nimport \"./OwnableERC721.sol\";\n\nimport { AV_WithdrawsDisabled, AV_WithdrawsEnabled, AV_AlreadyInitialized, AV_CallDisallowed, AV_NonWhitelistedCall } from \"../errors/Vault.sol\";\n\n/**\n * @title AssetVault\n * @author Non-Fungible Technologies, Inc.\n *\n * The Asset Vault is a vault for the storage of collateralized assets.\n * Designed for one-time use, like a piggy bank. Once withdrawals are enabled,\n * and the bank is broken, the vault can no longer be used or transferred.\n *\n * It starts in a deposit-only state. Funds cannot be withdrawn at this point. When\n * the owner calls \"enableWithdraw()\", the state is set to a withdrawEnabled state.\n * Withdraws cannot be disabled once enabled. This restriction protects integrations\n * and purchasers of AssetVaults from unexpected withdrawal and frontrunning attacks.\n * For exampple: someone buys an AV assuming it contains token X, but I withdraw token X\n * immediately before the sale concludes.\n *\n * @dev Asset Vaults support arbitrary external calls by either:\n *     - the current owner of the vault\n *     - someone who the current owner \"delegates\" through the ICallDelegator interface\n *\n * This is to enable airdrop claims by borrowers during loans and other forms of NFT utility.\n * In practice, LoanCore delegates to the borrower during the period of an open loan.\n * Arcade.xyz maintains an allowed and restricted list of calls to balance between utility and security.\n */\ncontract AssetVault is IAssetVault, OwnableERC721, Initializable, ERC1155Holder, ERC721Holder, ReentrancyGuard {\n    using Address for address;\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n\n    // ============================================ STATE ==============================================\n\n    /// @notice True if withdrawals are allowed out of this vault.\n    /// @dev Note once set to true, it cannot be reverted back to false.\n    bool public override withdrawEnabled;\n\n    /// @notice Whitelist contract to determine if a given external call is allowed.\n    ICallWhitelist public override whitelist;\n\n    // ========================================== CONSTRUCTOR ===========================================\n\n    /**\n     * @dev Initializes values so initialize cannot be called on template.\n     */\n    constructor() {\n        withdrawEnabled = true;\n        OwnableERC721._setNFT(msg.sender);\n    }\n\n    // ========================================== INITIALIZER ===========================================\n\n    /**\n     * @notice Initializes the contract, used on clone deployments. In practice,\n     *         always called by the VaultFactory contract.\n     *\n     * @param _whitelist            The contract maintaing the whitelist of allowed\n     *                              arbitrary calls.\n     */\n    function initialize(address _whitelist) external override initializer {\n        if (withdrawEnabled || ownershipToken != address(0)) revert AV_AlreadyInitialized(ownershipToken);\n        // set ownership to inherit from the factory who deployed us\n        // The factory should have a tokenId == uint256(address(this))\n        // whose owner has ownership control over this contract\n        OwnableERC721._setNFT(msg.sender);\n        whitelist = ICallWhitelist(_whitelist);\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    /**\n     * @inheritdoc OwnableERC721\n     */\n    function owner() public view override returns (address ownerAddress) {\n        return OwnableERC721.owner();\n    }\n\n    // ===================================== WITHDRAWAL OPERATIONS ======================================\n\n    /**\n     * @notice Enables withdrawals on the vault. Irreversible. Caller must be the\n     *         owner of the underlying ownership NFT.\n     *\n     * @dev Any integration should be aware that a withdraw-enabled vault cannot\n     *      be transferred (will revert).\n     *\n     */\n    function enableWithdraw() external override onlyOwner onlyWithdrawDisabled {\n        withdrawEnabled = true;\n        emit WithdrawEnabled(msg.sender);\n    }\n\n    /**\n     * @notice Withdraw entire balance of a given ERC20 token from the vault.\n     *         The vault must be in a \"withdrawEnabled\" state (non-transferrable),\n     *         and the caller must be the owner.\n     *\n     * @param token                 The ERC20 token to withdraw.\n     * @param to                    The recipient of the withdrawn funds.\n     */\n    function withdrawERC20(address token, address to) external override onlyOwner onlyWithdrawEnabled {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(to, balance);\n        emit WithdrawERC20(msg.sender, token, to, balance);\n    }\n\n    /**\n     * @notice Withdraw entire balance of a given ERC20 token from the vault.\n     *         The vault must be in a \"withdrawEnabled\" state (non-transferrable),\n     *         and the caller must be the owner. The specified token must\n     *         exist and be owned by this contract.\n     *\n     * @param token                 The token to withdraw.\n     * @param tokenId               The ID of the NFT to withdraw.\n     * @param to                    The recipient of the withdrawn token.\n     *\n     */\n    function withdrawERC721(\n        address token,\n        uint256 tokenId,\n        address to\n    ) external override onlyOwner onlyWithdrawEnabled {\n        IERC721(token).safeTransferFrom(address(this), to, tokenId);\n        emit WithdrawERC721(msg.sender, token, to, tokenId);\n    }\n\n    /**\n     * @notice Withdraw entire balance of a given ERC1155 token from the vault.\n     *         The vault must be in a \"withdrawEnabled\" state (non-transferrable),\n     *         and the caller must be the owner.\n     *\n     * @param token                 The ERC1155 token to withdraw.\n     * @param tokenId               The ID of the token to withdraw.\n     * @param to                    The recipient of the withdrawn funds.\n     */\n    function withdrawERC1155(\n        address token,\n        uint256 tokenId,\n        address to\n    ) external override onlyOwner onlyWithdrawEnabled {\n        uint256 balance = IERC1155(token).balanceOf(address(this), tokenId);\n        IERC1155(token).safeTransferFrom(address(this), to, tokenId, balance, \"\");\n        emit WithdrawERC1155(msg.sender, token, to, tokenId, balance);\n    }\n\n    /**\n     * @notice Withdraw entire balance of ETH from the vault.\n     *         The vault must be in a \"withdrawEnabled\" state (non-transferrable),\n     *         and the caller must be the owner.\n     *\n     * @param to                    The recipient of the withdrawn funds.\n     */\n    function withdrawETH(address to) external override onlyOwner onlyWithdrawEnabled nonReentrant {\n        // perform transfer\n        uint256 balance = address(this).balance;\n        payable(to).sendValue(balance);\n        emit WithdrawETH(msg.sender, to, balance);\n    }\n\n    // ====================================== UTILITY OPERATIONS ========================================\n\n    /**\n     * @notice Call a function on an external contract. Intended for claiming airdrops\n     *         and other forms of NFT utility. All allowed calls are whitelist by the\n     *         \"whitelist\" contract. The vault must have withdrawals disabled, and the caller\n     *         must either be the owner, or the owner must have explicitly\n     *         delegated this ability to the caller through ICallDelegator interface.\n     *\n     * @param to The contract address to call.\n     * @param data The data to call the contract with.\n     */\n    function call(address to, bytes calldata data) external override onlyWithdrawDisabled nonReentrant {\n        if (msg.sender != owner() && !ICallDelegator(owner()).canCallOn(msg.sender, address(this)))\n            revert AV_CallDisallowed(msg.sender);\n\n        if (!whitelist.isWhitelisted(to, bytes4(data[:4]))) revert AV_NonWhitelistedCall(to, bytes4(data[:4]));\n\n        to.functionCall(data);\n\n        emit Call(msg.sender, to, data);\n    }\n\n    // ============================================ HELPERS =============================================\n\n    /**\n     * @dev For methods only callable with withdraws enabled (all withdrawal operations).\n     */\n    modifier onlyWithdrawEnabled() {\n        if (!withdrawEnabled) revert AV_WithdrawsDisabled();\n        _;\n    }\n\n    /**\n     * @dev For methods only callable with withdraws disabled (call operations and enabling withdraws).\n     */\n    modifier onlyWithdrawDisabled() {\n        if (withdrawEnabled) revert AV_WithdrawsEnabled();\n        _;\n    }\n\n    /**\n     * @dev Fallback \"receive Ether\" function. Contract can hold Ether\n     *      which can be accessed using withdrawETH.\n     */\n    receive() external payable {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/ICallDelegator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface ICallDelegator {\n    // ============== View Functions ==============\n\n    function canCallOn(address caller, address vault) external view returns (bool);\n}\n"
    },
    "contracts/vault/OwnableERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport { OERC721_CallerNotOwner } from \"../errors/Vault.sol\";\n\n/**\n * @title OwnableERC721\n * @author Non-Fungible Technologies, Inc.\n *\n * Uses ERC721 ownership for access control to a set of contracts.\n * Ownership of underlying contract determined by ownership of a token ID,\n * where the token ID converts to an on-chain address.\n */\nabstract contract OwnableERC721 {\n    // ============================================ STATE ==============================================\n\n    /// @dev The ERC721 token that contract owners should have ownership of.\n    address public ownershipToken;\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    /**\n     * @notice Specifies the owner of the underlying token ID, derived\n     *         from the contract address of the contract implementing.\n     *\n     * @return ownerAddress         The owner of the underlying token derived from\n     *                              the calling address.\n     */\n    function owner() public view virtual returns (address ownerAddress) {\n        return IERC721(ownershipToken).ownerOf(uint256(uint160(address(this))));\n    }\n\n    // ============================================ HELPERS =============================================\n\n    /**\n     * @dev Set the ownership token - the ERC721 that specified who controls\n     *      defined addresses.\n     */\n    function _setNFT(address _ownershipToken) internal {\n        ownershipToken = _ownershipToken;\n    }\n\n    /**\n     * @dev Similar to Ownable - checks the method is being called by the owner,\n     *      where the owner is defined by the token ID in the ownership token which\n     *      maps to the calling contract address.\n     */\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert OERC721_CallerNotOwner(msg.sender);\n        _;\n    }\n}\n"
    },
    "contracts/errors/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/**\n * @title VaultErrors\n * @author Non-Fungible Technologies, Inc.\n *\n * This file contains all custom errors for vault contracts used by the protocol.\n * All errors prefixed by the contract that throws them (e.g., \"AV_\" for Asset Vault).\n * Errors located in one place to make it possible to holistically look at all\n * asset vault failure cases.\n */\n\n// ==================================== Asset Vault ======================================\n/// @notice All errors prefixed with AV_, to separate from other contracts in the protocol.\n\n/**\n * @notice Vault withdraws must be enabled.\n */\nerror AV_WithdrawsDisabled();\n\n/**\n * @notice Vault withdraws enabled.\n */\nerror AV_WithdrawsEnabled();\n\n/**\n * @notice Asset vault already initialized.\n *\n * @param ownershipToken                    Caller of initialize function in asset vault contract.\n */\nerror AV_AlreadyInitialized(address ownershipToken);\n\n/**\n * @notice Call disallowed.\n *\n * @param caller                             Msg.sender of the function call.\n */\nerror AV_CallDisallowed(address caller);\n\n/**\n * @notice Call disallowed.\n *\n * @param to                                The contract address to call.\n * @param data                              The data to call the contract with.\n */\nerror AV_NonWhitelistedCall(address to, bytes4 data);\n\n// ==================================== Ownable ERC721 ======================================\n/// @notice All errors prefixed with OERC721_, to separate from other contracts in the protocol.\n\n/**\n * @notice Function caller is not the owner.\n *\n * @param caller                             Msg.sender of the function call.\n */\nerror OERC721_CallerNotOwner(address caller);\n\n// ==================================== Vault Factory ======================================\n/// @notice All errors prefixed with VF_, to separate from other contracts in the protocol.\n\n/**\n * @notice Template contract is invalid.\n *\n * @param template                           Template contract to be cloned.\n */\nerror VF_InvalidTemplate(address template);\n\n/**\n * @notice Global index out of bounds.\n *\n * @param tokenId                            AW-V2 tokenId of the asset vault.\n */\nerror VF_TokenIdOutOfBounds(uint256 tokenId);\n\n/**\n * @notice Cannot transfer with withdraw enabled.\n *\n * @param tokenId                            AW-V2 tokenId of the asset vault.\n */\nerror VF_NoTransferWithdrawEnabled(uint256 tokenId);\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/vault/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"../interfaces/IAssetVault.sol\";\nimport \"../interfaces/IVaultFactory.sol\";\nimport \"../ERC721PermitUpgradeable.sol\";\n\nimport { VF_InvalidTemplate, VF_TokenIdOutOfBounds, VF_NoTransferWithdrawEnabled } from \"../errors/Vault.sol\";\n\n/**\n * @title VaultFactory\n * @author Non-Fungible Technologies, Inc.\n *\n * The Vault Facotry is used for creating and registering AssetVault contracts, which\n * is also an ERC721 that maps \"ownership\" of its tokens to ownership of created\n * vault assets (see OwnableERC721).\n *\n * Each Asset Vault is created via \"intializeBundle\", and uses a specified template\n * and the OpenZepppelin Clones library to cheaply deploy a new clone pointing to logic\n * in the template. The address the newly created vault is deployed to is converted\n * into a uint256, which ends up being the token ID minted.\n *\n * Using OwnableERC721, created Asset Vaults then map their own address back into\n * a uint256, and check the ownership of the token ID matching that uint256 within the\n * VaultFactory in order to determine their own contract owner. The VaultFactory contains\n * conveniences to allow switching between the address and uint256 formats.\n */\ncontract VaultFactory is ERC721EnumerableUpgradeable, ERC721PermitUpgradeable, IVaultFactory {\n    // ============================================ STATE ==============================================\n\n    /// @dev The template contract for asset vaults.\n    address public template;\n    /// @dev The CallWhitelist contract definining the calling restrictions for vaults.\n    address public whitelist;\n\n    // ========================================== CONSTRUCTOR ===========================================\n\n    /**\n     * @notice Runs the initializer function in an upgradeable contract.\n     *\n     * @dev Added unsafe-allow comment to notify upgrades plugin to accept the constructor.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ========================================== INITIALIZER ===========================================\n\n    function initialize(address _template, address _whitelist) public initializer {\n        __ERC721_init(\"Asset Wrapper V2\", \"AW-V2\");\n        __ERC721PermitUpgradeable_init(\"Asset Wrapper V2\");\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        if (_template == address(0)) revert VF_InvalidTemplate(_template);\n        template = _template;\n        whitelist = _whitelist;\n    }\n\n    // ===================================== UPGRADE AUTHORIZATION ======================================\n\n    /**\n     * @notice Authorization function to define who should be allowed to upgrade the contract.\n     *\n     * @param newImplementation     The address of the upgraded version of this contract.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    /**\n     * @notice Check if the given address is a vault instance created by this factory.\n     *\n     * @param instance              The address to check.\n     *\n     * @return validity             Whether the address is a valid vault instance.\n     */\n    function isInstance(address instance) external view override returns (bool validity) {\n        return _exists(uint256(uint160(instance)));\n    }\n\n    /**\n     * @notice Return the number of instances created by this factory.\n     *         Also the total supply of ERC721 bundle tokens.\n     *\n     * @return count                The total number of instances.\n     */\n    function instanceCount() external view override returns (uint256 count) {\n        return totalSupply();\n    }\n\n    /**\n     * @notice Return the address of the instance for the given token ID.\n     *\n     * @param tokenId               The token ID for which to find the instance.\n     *\n     * @return instance             The address of the derived instance.\n     */\n    function instanceAt(uint256 tokenId) external view override returns (address instance) {\n        // check _owners[tokenId] != address(0)\n        if (!_exists(tokenId)) revert VF_TokenIdOutOfBounds(tokenId);\n\n        return address(uint160(tokenId));\n    }\n\n    /**\n     * @notice Return the address of the instance for the given index. Allows\n     *         for enumeration over all instances.\n     *\n     * @param index                 The index for which to find the instance.\n     *\n     * @return instance             The address of the instance, derived from the corresponding\n     *                              token ID at the specified index.\n     */\n    function instanceAtIndex(uint256 index) external view override returns (address instance) {\n        return address(uint160(tokenByIndex(index)));\n    }\n\n    // ==================================== FACTORY OPERATIONS ==========================================\n\n    /**\n     * @notice Creates a new bundle token and vault contract for `to`. Its token ID will be\n     * automatically assigned (and available on the emitted {IERC721-Transfer} event)\n     *\n     * See {ERC721-_mint}.\n     *\n     * @param to                    The address that will own the new vault.\n     *\n     * @return tokenID              The token ID of the bundle token, derived from the vault address.\n     */\n    function initializeBundle(address to) external override returns (uint256) {\n        address vault = _create();\n\n        _mint(to, uint256(uint160(vault)));\n\n        emit VaultCreated(vault, to);\n        return uint256(uint160(vault));\n    }\n\n    /**\n     * @dev Creates and initializes a minimal proxy vault instance,\n     *      using the OpenZeppelin Clones library.\n     *\n     * @return vault                The address of the newly created vault.\n     */\n    function _create() internal returns (address vault) {\n        vault = Clones.clone(template);\n        IAssetVault(vault).initialize(whitelist);\n        return vault;\n    }\n\n    // ===================================== ERC721 UTILITIES ===========================================\n\n    /**\n     * @dev Hook that is called before any token transfer.\n     * @dev This notifies the vault contract about the ownership transfer.\n     *\n     * @dev Does not let tokens with withdraw enabled be transferred, which ensures\n     *      that items cannot be withdrawn in a frontrunning attack before loan origination.\n     *\n     * @param from                  The previous owner of the token.\n     * @param to                    The owner of the token after transfer.\n     * @param tokenId               The token ID.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        IAssetVault vault = IAssetVault(address(uint160(tokenId)));\n        if (vault.withdrawEnabled()) revert VF_NoTransferWithdrawEnabled(tokenId);\n\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721PermitUpgradeable, ERC721EnumerableUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/ERC721PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\n\nimport \"./interfaces/IERC721PermitUpgradeable.sol\";\n\nimport { ERC721P_DeadlineExpired, ERC721P_NotTokenOwner, ERC721P_InvalidSignature } from \"./errors/LendingUtils.sol\";\n\n/**\n * @title ERC721PermitUpgradeable\n * @author Non-Fungible Technologies, Inc.\n * @notice Upgradeable version of ERC721Permit.\n *\n * @dev Implementation of the ERC721 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol\n *\n * Adds the {permit} method, which can be used to change an account's ERC721 allowance (see {IERC721-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC721-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC721PermitUpgradeable is\n    ERC721Upgradeable,\n    IERC721PermitUpgradeable,\n    AccessControlUpgradeable,\n    EIP712Upgradeable,\n    UUPSUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    // ============================================ STATE ==============================================\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n\n    /// @dev Nonce for permit signatures.\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // ========================================== INITIALIZER ===========================================\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC721 token name.\n     *\n     * @param name                  The name of the signing domain.\n     */\n    function __ERC721PermitUpgradeable_init(string memory name) internal {\n        __EIP712_init(name, \"1\");\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    // ======================================= UPGRADE AUTHORIZATION ========================================\n\n    /**\n     * @notice Authorization function to define whether a contract upgrade should be allowed..\n     *\n     * @param newImplementation           The address of the upgraded verion of this contract.\n     */\n\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    // ==================================== ERC721PERMIT OPERATIONS ======================================\n\n    /**\n     * @notice Allows the spender to spend the token ID which is owned by owner,\n     * given owner's signed approval.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `owner` must be the owner of `tokenId`.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * @param owner                 The owner of the token being permitted.\n     * @param spender               The address allowed to spend the token.\n     * @param tokenId               The token ID of the given asset.\n     * @param deadline              The maximum timestamp the signature is valid for.\n     * @param v                     Component of the signature.\n     * @param r                     Component of the signature.\n     * @param s                     Component of the signature.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        if (block.timestamp > deadline) revert ERC721P_DeadlineExpired(deadline);\n        if (owner != ERC721Upgradeable.ownerOf(tokenId)) revert ERC721P_NotTokenOwner(owner);\n\n        bytes32 structHash = keccak256(\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, tokenId, _useNonce(owner), deadline)\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        if (signer != owner) revert ERC721P_InvalidSignature(signer);\n\n        _approve(spender, tokenId);\n    }\n\n    /**\n     * @notice Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated.\n     *\n     * Every successful call to permit increases the owner's nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * @param owner                 The given owner to check the nonce for.\n     *\n     * @return current              The current noonce for the owner.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @notice Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     *\n     * @return separator             The bytes for the domain separator.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev Consumes the nonce - returns the current value and increments.\n     *\n     * @param owner                 The address of the user to consume a nonce for.\n     *\n     * @return current              The current nonce, before incrementation.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AccessControlUpgradeable, ERC721Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/interfaces/IERC721PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\ninterface IERC721PermitUpgradeable is IERC721Upgradeable {\n    // ================ Permit Functionality ================\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    // ================ View Functions ================\n\n    function nonces(address owner) external view returns (uint256);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/OriginationController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport \"./interfaces/IOriginationController.sol\";\nimport \"./interfaces/ILoanCore.sol\";\nimport \"./interfaces/IERC721Permit.sol\";\nimport \"./interfaces/IAssetVault.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\nimport \"./interfaces/ISignatureVerifier.sol\";\n\nimport \"./InstallmentsCalc.sol\";\nimport \"./verifiers/ItemsVerifier.sol\";\nimport { OC_ZeroAddress, OC_InvalidState, OC_InvalidVerifier, OC_BatchLengthMismatch, OC_PredicateFailed, OC_SelfApprove, OC_ApprovedOwnLoan, OC_InvalidSignature, OC_CallerNotParticipant, OC_PrincipalTooLow, OC_LoanDuration, OC_InterestRate, OC_NumberInstallments, OC_SignatureIsExpired, OC_RolloverCurrencyMismatch, OC_RolloverCollateralMismatch } from \"./errors/Lending.sol\";\n\n/**\n * @title OriginationController\n * @author Non-Fungible Technologies, Inc.\n *\n * The Origination Controller is the entry point for all new loans\n * in the Arcade.xyz lending protocol. This contract should have the\n * exclusive responsibility to create new loans in LoanCore. All\n * permissioning, signature verification, and collateral verification\n * takes place in this contract. To originate a loan, the controller\n * also takes custody of both the collateral and loan principal.\n */\ncontract OriginationController is\n    Initializable,\n    InstallmentsCalc,\n    ContextUpgradeable,\n    IOriginationController,\n    EIP712Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    UUPSUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // ============================================ STATE ==============================================\n\n    // =================== Constants =====================\n\n    /// @notice EIP712 type hash for bundle-based signatures.\n    bytes32 private constant _TOKEN_ID_TYPEHASH =\n        keccak256(\n            // solhint-disable-next-line max-line-length\n            \"LoanTerms(uint32 durationSecs,uint32 deadline,uint24 numInstallments,uint160 interestRate,uint256 principal,address collateralAddress,uint256 collateralId,address payableCurrency,uint160 nonce,uint8 side)\"\n        );\n\n    /// @notice EIP712 type hash for item-based signatures.\n    bytes32 private constant _ITEMS_TYPEHASH =\n        keccak256(\n            // solhint-disable max-line-length\n            \"LoanTermsWithItems(uint32 durationSecs,uint32 deadline,uint24 numInstallments,uint160 interestRate,uint256 principal,address collateralAddress,bytes32 itemsHash,address payableCurrency,uint160 nonce,uint8 side)\"\n        );\n\n    // =============== Contract References ===============\n\n    address public loanCore;\n\n    // ================= Approval State ==================\n\n    /// @notice Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _signerApprovals;\n    /// @notice Mapping from address to whether that verifier contract has been whitelisted\n    mapping(address => bool) public allowedVerifiers;\n\n    // ========================================== CONSTRUCTOR ===========================================\n\n    /**\n     * @notice Runs the initializer function in an upgradeable contract.\n     *\n     *  @dev Add Unsafe-allow comment to notify upgrades plugin to accept the constructor.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ========================================== INITIALIZER ===========================================\n\n    /**\n     * @notice Creates a new origination controller contract, also initializing\n     * the parent signature verifier.\n     *\n     * @dev For this controller to work, it needs to be granted the ORIGINATOR_ROLE\n     *      in loan core after deployment.\n     *\n     * @param _loanCore                     The address of the loan core logic of the protocol.\n     */\n\n    function initialize(address _loanCore) public initializer {\n        __EIP712_init(\"OriginationController\", \"2\");\n        __Ownable_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n        if (_loanCore == address(0)) revert OC_ZeroAddress();\n\n        loanCore = _loanCore;\n    }\n\n    // ======================================= UPGRADE AUTHORIZATION ========================================\n\n    /**\n     * @notice Authorization function to define who should be allowed to upgrade the contract\n     *\n     * @param newImplementation           The address of the upgraded verion of this contract\n     */\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    // ==================================== ORIGINATION OPERATIONS ======================================\n\n    /**\n     * @notice Initializes a loan with Loan Core.\n     * @notice Works with either wrapped bundles with an ID, or specific ERC721 unwrapped NFTs.\n     *         In that case, collateralAddress should be the token contract.\n     *\n     * @dev The caller must be a borrower or lender, or approved by a borrower or lender.\n     * @dev The external signer must be a borrower or lender, or approved by a borrower or lender.\n     * @dev The external signer must come from the opposite side of the loan as the caller.\n     *\n     * @param loanTerms                     The terms agreed by the lender and borrower.\n     * @param borrower                      Address of the borrower.\n     * @param lender                        Address of the lender.\n     * @param sig                           The loan terms signature, with v, r, s fields, and a nonce.\n     * @param nonce                         The signature nonce.\n     *\n     * @return loanId                       The unique ID of the new loan.\n     */\n    function initializeLoan(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce\n    ) public override returns (uint256 loanId) {\n        _validateLoanTerms(loanTerms);\n\n        // Determine if signature needs to be on the borrow or lend side\n        Side neededSide = isSelfOrApproved(borrower, _msgSender()) ? Side.LEND : Side.BORROW;\n\n        (bytes32 sighash, address externalSigner) = recoverTokenSignature(loanTerms, sig, nonce, neededSide);\n\n        _validateCounterparties(borrower, lender, msg.sender, externalSigner, sig, sighash, neededSide);\n\n        ILoanCore(loanCore).consumeNonce(externalSigner, nonce);\n        loanId = _initialize(loanTerms, borrower, lender);\n    }\n\n    /**\n     * @notice Initializes a loan with Loan Core.\n     * @notice Compared to initializeLoan, this verifies the specific items in a bundle.\n     * @notice Only works with bundles implementing the IVaultFactory interface.\n     *\n     * @dev The caller must be a borrower or lender, or approved by a borrower or lender.\n     * @dev The external signer must be a borrower or lender, or approved by a borrower or lender.\n     * @dev The external signer must come from the opposite side of the loan as the caller.\n     *\n     * @param loanTerms                     The terms agreed by the lender and borrower.\n     * @param borrower                      Address of the borrower.\n     * @param lender                        Address of the lender.\n     * @param sig                           The loan terms signature, with v, r, s fields, and a nonce.\n     * @param nonce                         The signature nonce.\n     * @param itemPredicates                The predicate rules for the items in the bundle.\n     *\n     * @return loanId                       The unique ID of the new loan.\n     */\n    function initializeLoanWithItems(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce,\n        LoanLibrary.Predicate[] calldata itemPredicates\n    ) public override returns (uint256 loanId) {\n        _validateLoanTerms(loanTerms);\n\n        // Determine if signature needs to be on the borrow or lend side\n        Side neededSide = isSelfOrApproved(borrower, _msgSender()) ? Side.LEND : Side.BORROW;\n\n        address vault = IVaultFactory(loanTerms.collateralAddress).instanceAt(loanTerms.collateralId);\n        (bytes32 sighash, address externalSigner) = recoverItemsSignature(\n            loanTerms,\n            sig,\n            nonce,\n            neededSide,\n            keccak256(abi.encode(itemPredicates))\n        );\n\n        _validateCounterparties(borrower, lender, msg.sender, externalSigner, sig, sighash, neededSide);\n\n        for (uint256 i = 0; i < itemPredicates.length; i++) {\n            // Verify items are held in the wrapper\n            address verifier = itemPredicates[i].verifier;\n            if (!isAllowedVerifier(verifier)) revert OC_InvalidVerifier(verifier);\n\n            if (!IArcadeSignatureVerifier(verifier).verifyPredicates(itemPredicates[i].data, vault)) {\n                revert OC_PredicateFailed(verifier, itemPredicates[i].data, vault);\n            }\n        }\n\n        ILoanCore(loanCore).consumeNonce(externalSigner, nonce);\n        loanId = _initialize(loanTerms, borrower, lender);\n    }\n\n    /**\n     * @notice Initializes a loan with Loan Core, with a permit signature instead of pre-approved collateral.\n     *\n     * @dev The caller must be a borrower or lender, or approved by a borrower or lender.\n     * @dev The external signer must be a borrower or lender, or approved by a borrower or lender.\n     * @dev The external signer must come from the opposite side of the loan as the caller.\n     *\n     * @param loanTerms                     The terms agreed by the lender and borrower.\n     * @param borrower                      Address of the borrower.\n     * @param lender                        Address of the lender.\n     * @param sig                           The loan terms signature, with v, r, s fields.\n     * @param nonce                         The signature nonce for the loan terms signature.\n     * @param collateralSig                 The collateral permit signature, with v, r, s fields.\n     * @param permitDeadline                The last timestamp for which the signature is valid.\n     *\n     * @return loanId                       The unique ID of the new loan.\n     */\n    function initializeLoanWithCollateralPermit(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce,\n        Signature calldata collateralSig,\n        uint256 permitDeadline\n    ) external override returns (uint256 loanId) {\n        IERC721Permit(loanTerms.collateralAddress).permit(\n            borrower,\n            address(this),\n            loanTerms.collateralId,\n            permitDeadline,\n            collateralSig.v,\n            collateralSig.r,\n            collateralSig.s\n        );\n\n        loanId = initializeLoan(loanTerms, borrower, lender, sig, nonce);\n    }\n\n    /**\n     * @notice Initializes a loan with Loan Core, with a permit signature instead of pre-approved collateral.\n     * @notice Compared to initializeLoanWithCollateralPermit, this verifies the specific items in a bundle.\n     *\n     * @dev The caller must be a borrower or lender, or approved by a borrower or lender.\n     * @dev The external signer must be a borrower or lender, or approved by a borrower or lender.\n     * @dev The external signer must come from the opposite side of the loan as the caller.\n     *\n     * @param loanTerms                     The terms agreed by the lender and borrower.\n     * @param borrower                      Address of the borrower.\n     * @param lender                        Address of the lender.\n     * @param sig                           The loan terms signature, with v, r, s fields.\n     * @param nonce                         The signature nonce for the loan terms signature.\n     * @param collateralSig                 The collateral permit signature, with v, r, s fields.\n     * @param permitDeadline                The last timestamp for which the signature is valid.\n     * @param itemPredicates                The predicate rules for the items in the bundle.\n     *\n     * @return loanId                       The unique ID of the new loan.\n     */\n    function initializeLoanWithCollateralPermitAndItems(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce,\n        Signature calldata collateralSig,\n        uint256 permitDeadline,\n        LoanLibrary.Predicate[] calldata itemPredicates\n    ) external override returns (uint256 loanId) {\n        IERC721Permit(loanTerms.collateralAddress).permit(\n            borrower,\n            address(this),\n            loanTerms.collateralId,\n            permitDeadline,\n            collateralSig.v,\n            collateralSig.r,\n            collateralSig.s\n        );\n\n        loanId = initializeLoanWithItems(loanTerms, borrower, lender, sig, nonce, itemPredicates);\n    }\n\n    /**\n     * @notice Rolls over an existing loan via Loan Core, using a signature\n     *         for a new loan to create. The lender can be the same lender as\n     *         the loan to be rolled over, or a new lender. The net funding between\n     *         the old and new loan is calculated, with funds withdrawn from relevant\n     *         parties.\n     *\n     * @param oldLoanId                     The ID of the old loan.\n     * @param loanTerms                     The terms agreed by the lender and borrower.\n     * @param lender                        Address of the lender.\n     * @param sig                           The loan terms signature, with v, r, s fields.\n     * @param nonce                         The signature nonce for the loan terms signature.\n     *\n     * @return newLoanId                    The unique ID of the new loan.\n     */\n    function rolloverLoan(\n        uint256 oldLoanId,\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce\n    ) public override returns (uint256 newLoanId) {\n        _validateLoanTerms(loanTerms);\n\n        LoanLibrary.LoanData memory data = ILoanCore(loanCore).getLoan(oldLoanId);\n        if (data.state != LoanLibrary.LoanState.Active) revert OC_InvalidState(data.state);\n\n        address borrower = IERC721(ILoanCore(loanCore).borrowerNote()).ownerOf(oldLoanId);\n        // Determine if signature needs to be on the borrow or lend side\n        Side neededSide = isSelfOrApproved(borrower, _msgSender()) ? Side.LEND : Side.BORROW;\n\n        _validateRollover(data.terms, loanTerms);\n\n        (bytes32 sighash, address externalSigner) = recoverTokenSignature(loanTerms, sig, nonce, neededSide);\n\n        _validateCounterparties(borrower, lender, msg.sender, externalSigner, sig, sighash, neededSide);\n\n        ILoanCore(loanCore).consumeNonce(externalSigner, nonce);\n\n        newLoanId = _rollover(oldLoanId, loanTerms, borrower, lender);\n    }\n\n    /**\n     * @notice Rolls over an existing loan via Loan Core, using a signature\n     *         for a new loan to create (of items type). The lender can be the same lender as\n     *         the loan to be rolled over, or a new lender. The net funding between\n     *         the old and new loan is calculated, with funds withdrawn from relevant\n     *         parties.\n     *\n     * @param oldLoanId                     The ID of the old loan.\n     * @param loanTerms                     The terms agreed by the lender and borrower.\n     * @param lender                        Address of the lender.\n     * @param sig                           The loan terms signature, with v, r, s fields.\n     * @param nonce                         The signature nonce for the loan terms signature.\n     * @param itemPredicates                The predicate rules for the items in the bundle.\n     *\n     * @return newLoanId                    The unique ID of the new loan.\n     */\n    function rolloverLoanWithItems(\n        uint256 oldLoanId,\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address lender,\n        Signature calldata sig,\n        uint160 nonce,\n        LoanLibrary.Predicate[] calldata itemPredicates\n    ) public override returns (uint256 newLoanId) {\n        _validateLoanTerms(loanTerms);\n\n        LoanLibrary.LoanData memory data = ILoanCore(loanCore).getLoan(oldLoanId);\n        _validateRollover(data.terms, loanTerms);\n\n        address borrower = IERC721(ILoanCore(loanCore).borrowerNote()).ownerOf(oldLoanId);\n        // Determine if signature needs to be on the borrow or lend side\n        Side neededSide = isSelfOrApproved(borrower, _msgSender()) ? Side.LEND : Side.BORROW;\n\n        address vault = IVaultFactory(loanTerms.collateralAddress).instanceAt(loanTerms.collateralId);\n        (bytes32 sighash, address externalSigner) = recoverItemsSignature(\n            loanTerms,\n            sig,\n            nonce,\n            neededSide,\n            keccak256(abi.encode(itemPredicates))\n        );\n\n        _validateCounterparties(borrower, lender, msg.sender, externalSigner, sig, sighash, neededSide);\n\n        for (uint256 i = 0; i < itemPredicates.length; i++) {\n            // Verify items are held in the wrapper\n            address verifier = itemPredicates[i].verifier;\n            if (!isAllowedVerifier(verifier)) revert OC_InvalidVerifier(verifier);\n\n            if (!IArcadeSignatureVerifier(verifier).verifyPredicates(itemPredicates[i].data, vault)) {\n                revert OC_PredicateFailed(verifier, itemPredicates[i].data, vault);\n            }\n        }\n\n        ILoanCore(loanCore).consumeNonce(externalSigner, nonce);\n\n        newLoanId = _rollover(oldLoanId, loanTerms, borrower, lender);\n    }\n\n    // ==================================== PERMISSION MANAGEMENT =======================================\n\n    /**\n     * @notice Approve a third party to sign or initialize loans on a counterparties' behalf.\n     * @notice Useful to multisig counterparties (who cannot sign themselves) or third-party integrations.\n     *\n     * @param signer                        The party to set approval for.\n     * @param approved                      Whether the party should be approved.\n     */\n    function approve(address signer, bool approved) public override {\n        if (signer == msg.sender) revert OC_SelfApprove(msg.sender);\n\n        _signerApprovals[msg.sender][signer] = approved;\n\n        emit Approval(msg.sender, signer, approved);\n    }\n\n    /**\n     * @notice Reports whether a party is approved to act on a counterparties' behalf.\n     *\n     * @param owner                         The grantor of permission.\n     * @param signer                        The grantee of permission.\n     *\n     * @return isApproved                   Whether the grantee has been approved by the grantor.\n     */\n    function isApproved(address owner, address signer) public view virtual override returns (bool) {\n        return _signerApprovals[owner][signer];\n    }\n\n    /**\n     * @notice Reports whether the signer matches the target or is approved by the target.\n     *\n     * @param target                        The grantor of permission - should be a smart contract.\n     * @param sig                           A struct containing the signature data (for checking EIP-1271).\n     * @param sighash                   The hash of the signature payload (used for EIP-1271 check).\n     *\n     * @return isApprovedForContract        Whether the signer is either the grantor themselves, or approved.\n     */\n    function isApprovedForContract(\n        address target,\n        Signature calldata sig,\n        bytes32 sighash\n    ) public view override returns (bool) {\n        bytes memory signature = new bytes(65);\n\n        // Construct byte array directly in assembly for efficiency\n        uint8 v = sig.v;\n        bytes32 r = sig.r;\n        bytes32 s = sig.s;\n\n        assembly {\n            mstore(add(signature, 32), r)\n            mstore(add(signature, 64), s)\n            mstore(add(signature, 96), v)\n        }\n\n        // Convert sig struct to bytes\n        (bool success, bytes memory result) = target.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, sighash, signature)\n        );\n        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n    }\n\n    /**\n     * @notice Reports whether the signer matches the target or is approved by the target.\n     *\n     * @param target                        The grantor of permission.\n     * @param signer                        The grantee of permission.\n     *\n     * @return isSelfOrApproved             Whether the signer is either the grantor themselves, or approved.\n     */\n    function isSelfOrApproved(address target, address signer) public view override returns (bool) {\n        return target == signer || isApproved(target, signer);\n    }\n\n    // ==================================== SIGNATURE VERIFICATION ======================================\n\n    /**\n     * @notice Determine the external signer for a signature specifying only a collateral address and ID.\n     *\n     * @param loanTerms                     The terms of the loan.\n     * @param sig                           The signature, with v, r, s fields.\n     * @param nonce                         The signature nonce.\n     * @param side                          The side of the loan being signed.\n     *\n     * @return sighash                      The hash that was signed.\n     * @return signer                       The address of the recovered signer.\n     */\n    function recoverTokenSignature(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        Signature calldata sig,\n        uint160 nonce,\n        Side side\n    ) public view override returns (bytes32 sighash, address signer) {\n        bytes32 loanHash = keccak256(\n            abi.encode(\n                _TOKEN_ID_TYPEHASH,\n                loanTerms.durationSecs,\n                loanTerms.deadline,\n                loanTerms.numInstallments,\n                loanTerms.interestRate,\n                loanTerms.principal,\n                loanTerms.collateralAddress,\n                loanTerms.collateralId,\n                loanTerms.payableCurrency,\n                nonce,\n                uint8(side)\n            )\n        );\n\n        sighash = _hashTypedDataV4(loanHash);\n        signer = ECDSA.recover(sighash, sig.v, sig.r, sig.s);\n    }\n\n    /**\n     * @notice Determine the external signer for a signature specifying specific items.\n     * @dev    Bundle ID should _not_ be included in this signature, because the loan\n     *         can be initiated with any arbitrary bundle - as long as the bundle contains the items.\n     *\n     * @param loanTerms                     The terms of the loan.\n     * @param sig                           The loan terms signature, with v, r, s fields.\n     * @param nonce                         The signature nonce.\n     * @param side                          The side of the loan being signed.\n     * @param itemsHash                     The required items in the specified bundle.\n     *\n     * @return sighash                      The hash that was signed.\n     * @return signer                       The address of the recovered signer.\n     */\n    function recoverItemsSignature(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        Signature calldata sig,\n        uint160 nonce,\n        Side side,\n        bytes32 itemsHash\n    ) public view override returns (bytes32 sighash, address signer) {\n        bytes32 loanHash = keccak256(\n            abi.encode(\n                _ITEMS_TYPEHASH,\n                loanTerms.durationSecs,\n                loanTerms.deadline,\n                loanTerms.numInstallments,\n                loanTerms.interestRate,\n                loanTerms.principal,\n                loanTerms.collateralAddress,\n                itemsHash,\n                loanTerms.payableCurrency,\n                nonce,\n                uint8(side)\n            )\n        );\n\n        sighash = _hashTypedDataV4(loanHash);\n        signer = ECDSA.recover(sighash, sig.v, sig.r, sig.s);\n    }\n\n    // ==================================== VERIFICATION WHITELIST ======================================\n\n    /**\n     * @notice Manage whitelist for contracts that are allowed to act as a predicate verifier.\n     *         Prevents counterparties from abusing misleading/obscure verification logic.\n     *         The contract owner should take extra care in whitelisting third-party verification contracts:\n     *         for instance, an upgradeable third-party verifier controlled by a borrower could be maliciously\n     *         upgraded to approve an empty bundle.\n     *\n     * @param verifier              The specified verifier contract, should implement IArcadeSignatureVerifier.\n     * @param isAllowed             Whether the specified contract should be allowed.\n     */\n    function setAllowedVerifier(address verifier, bool isAllowed) public override onlyOwner {\n        if (verifier == address(0)) revert OC_ZeroAddress();\n\n        allowedVerifiers[verifier] = isAllowed;\n\n        emit SetAllowedVerifier(verifier, isAllowed);\n    }\n\n    /**\n     * @notice Batch update for verification whitelist, in case of multiple verifiers\n     *         active in production.\n     *\n     * @param verifiers             The list of specified verifier contracts, should implement IArcadeSignatureVerifier.\n     * @param isAllowed             Whether the specified contracts should be allowed, respectively.\n     */\n    function setAllowedVerifierBatch(address[] calldata verifiers, bool[] calldata isAllowed) external override {\n        if (verifiers.length != isAllowed.length) revert OC_BatchLengthMismatch();\n\n        for (uint256 i = 0; i < verifiers.length; i++) {\n            setAllowedVerifier(verifiers[i], isAllowed[i]);\n        }\n    }\n\n    /**\n     * @notice Return whether the address can be used as a verifier.\n     *\n     * @param verifier             The verifier contract to query.\n     *\n     * @return isVerified          Whether the contract is verified.\n     */\n    function isAllowedVerifier(address verifier) public view override returns (bool) {\n        return allowedVerifiers[verifier];\n    }\n\n    // =========================================== HELPERS ==============================================\n\n    /**\n     * @dev Validates argument bounds for the loan terms.\n     *\n     * @param terms                     The terms of the loan.\n     */\n    function _validateLoanTerms(LoanLibrary.LoanTerms memory terms) internal view {\n        // principal must be greater than or equal to 10000 wei\n        if (terms.principal < 10_000) revert OC_PrincipalTooLow(terms.principal);\n\n        // loan duration must be greater than 1 hr and less than 3 years\n        if (terms.durationSecs < 3600 || terms.durationSecs > 94_608_000) revert OC_LoanDuration(terms.durationSecs);\n\n        // interest rate must be greater than or equal to 0.01%\n        // and less than 10,000% (1e8 basis points)\n        if (terms.interestRate < 1e18 || terms.interestRate > 1e24) revert OC_InterestRate(terms.interestRate);\n\n        // number of installments must be between 2 and 1000.\n        if (terms.numInstallments == 1 || terms.numInstallments > 1_000)\n            revert OC_NumberInstallments(terms.numInstallments);\n\n        // signature must not have already expired\n        if (terms.deadline < block.timestamp) revert OC_SignatureIsExpired(terms.deadline);\n    }\n\n    /**\n     * @dev Validate the rules for rolling over a loan - must be using the same\n     *      currency and collateral.\n     *\n     * @param oldTerms              The terms of the old loan, fetched from LoanCore.\n     * @param newTerms              The terms of the new loan, provided by the caller.\n     */\n    function _validateRollover(LoanLibrary.LoanTerms memory oldTerms, LoanLibrary.LoanTerms memory newTerms)\n        internal\n        pure\n    {\n        if (newTerms.payableCurrency != oldTerms.payableCurrency)\n            revert OC_RolloverCurrencyMismatch(oldTerms.payableCurrency, newTerms.payableCurrency);\n\n        if (newTerms.collateralAddress != oldTerms.collateralAddress || newTerms.collateralId != oldTerms.collateralId)\n            revert OC_RolloverCollateralMismatch(\n                oldTerms.collateralAddress,\n                oldTerms.collateralId,\n                newTerms.collateralAddress,\n                newTerms.collateralId\n            );\n    }\n\n    /**\n     * @dev Ensure that one counterparty has signed the loan terms, and the other\n     *      has initiated the transaction.\n     *\n     * @param borrower                  The specified borrower for the loan.\n     * @param lender                    The specified lender for the loan.\n     * @param caller                    The address initiating the transaction.\n     * @param signer                    The address recovered from the loan terms signature.\n     * @param sig                       A struct containing the signature data (for checking EIP-1271).\n     * @param sighash                   The hash of the signature payload (used for EIP-1271 check).\n     * @param neededSide                The side of the loan the signature will take (lend or borrow).\n     */\n    function _validateCounterparties(\n        address borrower,\n        address lender,\n        address caller,\n        address signer,\n        Signature calldata sig,\n        bytes32 sighash,\n        Side neededSide\n    ) internal view {\n        if (caller == signer) revert OC_ApprovedOwnLoan(caller);\n\n        address shouldBeSigner = neededSide == Side.LEND ? lender : borrower;\n        address shouldBeCaller = shouldBeSigner == lender ? borrower : lender;\n\n        if (!isSelfOrApproved(shouldBeCaller, caller) && !isApprovedForContract(shouldBeCaller, sig, sighash)) {\n            revert OC_CallerNotParticipant(msg.sender);\n        }\n\n        if (!isSelfOrApproved(shouldBeSigner, signer) && !isApprovedForContract(shouldBeSigner, sig, sighash)) {\n            revert OC_InvalidSignature(shouldBeSigner, signer);\n        }\n    }\n\n    /**\n     * @dev Perform loan initialization. Take custody of both principal and\n     *      collateral, and tell LoanCore to create and start a loan.\n     *\n     * @param loanTerms                     The terms agreed by the lender and borrower.\n     * @param borrower                      Address of the borrower.\n     * @param lender                        Address of the lender.\n     *\n     * @return loanId                       The unique ID of the new loan.\n     */\n    function _initialize(\n        LoanLibrary.LoanTerms calldata loanTerms,\n        address borrower,\n        address lender\n    ) internal nonReentrant returns (uint256 loanId) {\n        // Take custody of funds\n        IERC20Upgradeable(loanTerms.payableCurrency).safeTransferFrom(lender, address(this), loanTerms.principal);\n        IERC20Upgradeable(loanTerms.payableCurrency).approve(loanCore, loanTerms.principal);\n\n        IERC721(loanTerms.collateralAddress).transferFrom(borrower, address(this), loanTerms.collateralId);\n        IERC721(loanTerms.collateralAddress).approve(loanCore, loanTerms.collateralId);\n\n        // Start loan\n        loanId = ILoanCore(loanCore).startLoan(lender, borrower, loanTerms);\n    }\n\n    /**\n     * @dev Perform loan rollover. Take custody of both principal and\n     *      collateral, and tell LoanCore to roll over the existing loan.\n     *\n     * @param oldLoanId                     The ID of the loan to be rolled over.\n     * @param newTerms                      The terms agreed by the lender and borrower.\n     * @param borrower                      Address of the borrower.\n     * @param lender                        Address of the lender.\n     *\n     * @return loanId                       The unique ID of the new loan.\n     */\n    function _rollover(\n        uint256 oldLoanId,\n        LoanLibrary.LoanTerms calldata newTerms,\n        address borrower,\n        address lender\n    ) internal nonReentrant returns (uint256 loanId) {\n        LoanLibrary.LoanData memory oldLoanData = ILoanCore(loanCore).getLoan(oldLoanId);\n        LoanLibrary.LoanTerms memory oldTerms = oldLoanData.terms;\n\n        address oldLender = ILoanCore(loanCore).lenderNote().ownerOf(oldLoanId);\n        IERC20Upgradeable payableCurrency = IERC20Upgradeable(oldTerms.payableCurrency);\n        uint256 rolloverFee = ILoanCore(loanCore).feeController().getRolloverFee();\n\n        // Settle amounts\n        RolloverAmounts memory amounts = _calculateRolloverAmounts(\n            oldLoanData,\n            newTerms,\n            lender,\n            oldLender,\n            rolloverFee\n        );\n\n        // Collect funds\n        uint256 settledAmount;\n        if (lender != oldLender) {\n            // Take new principal from lender\n            // OriginationController should have collected\n            payableCurrency.safeTransferFrom(lender, address(this), newTerms.principal);\n            settledAmount += newTerms.principal;\n        }\n\n        if (amounts.needFromBorrower > 0) {\n            // Borrower must pay difference\n            // OriginationController should have collected\n            payableCurrency.safeTransferFrom(borrower, address(this), amounts.needFromBorrower);\n            settledAmount += amounts.needFromBorrower;\n        } else if (amounts.leftoverPrincipal > 0 && lender == oldLender) {\n            // Lender must pay difference\n            // OriginationController should have collected\n            // Make sure to collect fee\n            payableCurrency.safeTransferFrom(lender, address(this), amounts.leftoverPrincipal);\n            settledAmount += amounts.leftoverPrincipal;\n        }\n\n        {\n            payableCurrency.approve(loanCore, settledAmount);\n\n            loanId = ILoanCore(loanCore).rollover(\n                oldLoanId,\n                borrower,\n                lender,\n                newTerms,\n                settledAmount,\n                amounts.amountToOldLender,\n                amounts.amountToLender,\n                amounts.amountToBorrower\n            );\n        }\n    }\n\n    /**\n     * @dev Calculate the net amounts needed for the rollover from each party - the\n     *      borrower, the new lender, and the old lender (can be same as new lender).\n     *      Determine the amount to either pay or withdraw from the borrower, and\n     *      any payments to be sent to the old lender.\n     *\n     * @param oldLoanData           The LoanData struct for the old loan.\n     * @param newTerms              The terms struct for the new loan.\n     * @param lender                The lender for the new loan.\n     * @param oldLender             The lender for the existing loan.\n     * @param rolloverFee           The protocol fee for rollovers.\n     *\n     * @return amounts              The net amounts owed to each party.\n     */\n    function _calculateRolloverAmounts(\n        LoanLibrary.LoanData memory oldLoanData,\n        LoanLibrary.LoanTerms calldata newTerms,\n        address lender,\n        address oldLender,\n        uint256 rolloverFee\n    ) internal view returns (RolloverAmounts memory amounts) {\n        LoanLibrary.LoanTerms memory oldTerms = oldLoanData.terms;\n\n        uint256 repayAmount;\n        if (oldTerms.numInstallments == 0) {\n            repayAmount = getFullInterestAmount(oldTerms.principal, oldTerms.interestRate);\n        } else {\n            (uint256 interestDue, uint256 lateFees, ) = _calcAmountsDue(\n                oldLoanData.balance,\n                oldLoanData.startDate,\n                oldTerms.durationSecs,\n                oldTerms.numInstallments,\n                oldLoanData.numInstallmentsPaid,\n                oldTerms.interestRate\n            );\n\n            repayAmount = oldLoanData.balance + interestDue + lateFees;\n        }\n\n        amounts.fee = (newTerms.principal * rolloverFee) / BASIS_POINTS_DENOMINATOR;\n        uint256 borrowerWillGet = newTerms.principal - amounts.fee;\n\n        // Settle amounts\n        if (repayAmount > borrowerWillGet) {\n            amounts.needFromBorrower = repayAmount - borrowerWillGet;\n        } else {\n            amounts.leftoverPrincipal = newTerms.principal - repayAmount;\n            amounts.amountToBorrower = amounts.leftoverPrincipal - amounts.fee;\n        }\n\n        // Collect funds\n        if (lender != oldLender) {\n            amounts.amountToOldLender = repayAmount;\n            amounts.amountToLender = 0;\n        } else {\n            amounts.amountToOldLender = 0;\n\n            if (amounts.needFromBorrower > 0 && repayAmount > newTerms.principal) {\n                amounts.amountToLender = repayAmount - newTerms.principal;\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/test/MockOriginationController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../OriginationController.sol\";\n\ncontract MockOriginationController is OriginationController {\n    function version() public pure returns (string memory) {\n        return \"This is OriginationController V2!\";\n    }\n\n    function isApproved(address owner, address signer) public pure override returns (bool) {\n        return owner != signer;\n    }\n}\n"
    },
    "contracts/LoanCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\n\nimport \"./interfaces/ICallDelegator.sol\";\nimport \"./interfaces/IPromissoryNote.sol\";\nimport \"./interfaces/IAssetVault.sol\";\nimport \"./interfaces/IFeeController.sol\";\nimport \"./interfaces/ILoanCore.sol\";\n\nimport \"./InstallmentsCalc.sol\";\nimport \"./PromissoryNote.sol\";\nimport \"./vault/OwnableERC721.sol\";\nimport { LC_ZeroAddress, LC_CollateralInUse, LC_CollateralNotInUse, LC_InvalidState, LC_NotExpired, LC_BalanceGTZero, LC_NonceUsed, LC_LoanNotDefaulted } from \"./errors/Lending.sol\";\n\n/**\n * @title LoanCore\n * @author Non-Fungible Technologies, Inc.\n *\n * The LoanCore lending contract is the heart of the Arcade.xyz lending protocol.\n * It stores and maintains loan state, enforces loan lifecycle invariants, takes\n * escrow of assets during an active loans, governs the release of collateral on\n * repayment or default, and tracks signature nonces for loan consent.\n *\n * Also contains logic for approving Asset Vault calls using the\n * ICallDelegator interface.\n */\ncontract LoanCore is\n    ILoanCore,\n    Initializable,\n    InstallmentsCalc,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ICallDelegator,\n    UUPSUpgradeable\n{\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // ============================================ STATE ==============================================\n\n    // =================== Constants =====================\n\n    bytes32 public constant ORIGINATOR_ROLE = keccak256(\"ORIGINATOR_ROLE\");\n    bytes32 public constant REPAYER_ROLE = keccak256(\"REPAYER_ROLE\");\n    bytes32 public constant FEE_CLAIMER_ROLE = keccak256(\"FEE_CLAIMER_ROLE\");\n\n    uint256 private constant PERCENT_MISSED_FOR_LENDER_CLAIM = 4000;\n    // =============== Contract References ================\n\n    IPromissoryNote public override borrowerNote;\n    IPromissoryNote public override lenderNote;\n    IFeeController public override feeController;\n\n    // =================== Loan State =====================\n\n    CountersUpgradeable.Counter private loanIdTracker;\n    mapping(uint256 => LoanLibrary.LoanData) private loans;\n    // key is hash of (collateralAddress, collateralId)\n    mapping(bytes32 => bool) private collateralInUse;\n    mapping(address => mapping(uint160 => bool)) public usedNonces;\n\n    // ========================================== CONSTRUCTOR ===========================================\n\n    /**\n     * @notice Runs the initializer function in an upgradeable contract.\n     *\n     * @dev Add Unsafe-allow comment to notify upgrades plugin to accept the constructor.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ========================================== INITIALIZER ===========================================\n\n    /**\n     * @notice Initializes tehe loan core contract, by initializing parent\n     *         contracts, setting up roles, and setting up contract references.\n     *\n     * @param _feeController      The address of the contract governing protocol fees.\n     */\n    function initialize(\n        IFeeController _feeController,\n        IPromissoryNote _borrowerNote,\n        IPromissoryNote _lenderNote\n    ) public initializer {\n        if (address(_feeController) == address(0)) revert LC_ZeroAddress();\n        if (address(_borrowerNote) == address(0)) revert LC_ZeroAddress();\n        if (address(_lenderNote) == address(0)) revert LC_ZeroAddress();\n\n        // only those with FEE_CLAIMER_ROLE can update or grant FEE_CLAIMER_ROLE\n        __AccessControl_init();\n        __UUPSUpgradeable_init_unchained();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(FEE_CLAIMER_ROLE, _msgSender());\n        _setRoleAdmin(FEE_CLAIMER_ROLE, FEE_CLAIMER_ROLE);\n\n        feeController = _feeController;\n\n        /// @dev Although using references for both promissory notes, these\n        ///      must be fresh versions and cannot be re-used across multiple\n        ///      loanCore instances, to ensure loanId <> tokenID parity\n        borrowerNote = _borrowerNote;\n        lenderNote = _lenderNote;\n\n        // Avoid having loanId = 0\n        loanIdTracker.increment();\n    }\n\n    // ===================================== UPGRADE AUTHORIZATION ======================================\n\n    /**\n     * @notice Authorization function to define whether a contract upgrade should be allowed.\n     *\n     * @param newImplementation     The address of the upgraded verion of this contract.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n    // ====================================== LIFECYCLE OPERATIONS ======================================\n\n    /**\n     * @notice Start a loan, matching a set of terms, with a given\n     *         lender and borrower. Collects collateral and distributes\n     *         principal, along with collecting an origination fee for the\n     *         protocol. Can only be called by OriginationController.\n     *\n     * @param lender                The lender for the loan.\n     * @param borrower              The borrower for the loan.\n     * @param terms                 The terms of the loan.\n     *\n     * @return loanId               The ID of the newly created loan.\n     */\n    function startLoan(\n        address lender,\n        address borrower,\n        LoanLibrary.LoanTerms calldata terms\n    ) external override whenNotPaused onlyRole(ORIGINATOR_ROLE) returns (uint256 loanId) {\n        // check collateral is not already used in a loan.\n        bytes32 collateralKey = keccak256(abi.encode(terms.collateralAddress, terms.collateralId));\n        if (collateralInUse[collateralKey]) revert LC_CollateralInUse(terms.collateralAddress, terms.collateralId);\n\n        // get current loanId and increment for next function call\n        loanId = loanIdTracker.current();\n        loanIdTracker.increment();\n\n        // Initiate loan state\n        loans[loanId] = LoanLibrary.LoanData({\n            terms: terms,\n            state: LoanLibrary.LoanState.Active,\n            startDate: uint160(block.timestamp),\n            balance: terms.principal,\n            balancePaid: 0,\n            lateFeesAccrued: 0,\n            numInstallmentsPaid: 0\n        });\n\n        collateralInUse[collateralKey] = true;\n\n        // Distribute notes and principal\n        _mintLoanNotes(loanId, borrower, lender);\n\n        IERC721Upgradeable(terms.collateralAddress).transferFrom(_msgSender(), address(this), terms.collateralId);\n\n        IERC20Upgradeable(terms.payableCurrency).safeTransferFrom(_msgSender(), address(this), terms.principal);\n\n        IERC20Upgradeable(terms.payableCurrency).safeTransfer(borrower, _getPrincipalLessFees(terms.principal));\n\n        emit LoanStarted(loanId, lender, borrower);\n    }\n\n    /**\n     * @notice Repay the given loan. Can only be called by RepaymentController,\n     *         which verifies repayment conditions. This method will calculate\n     *         the total interest due, collect it from the borrower, and redistribute\n     *         principal + interest to he lender, and collateral to the borrower.\n     *         All promissory notes will be burned and the loan will be marked as complete.\n     *\n     * @param loanId                The ID of the loan to repay.\n     */\n    function repay(uint256 loanId) external override onlyRole(REPAYER_ROLE) {\n        LoanLibrary.LoanData memory data = loans[loanId];\n        // ensure valid initial loan state when starting loan\n        if (data.state != LoanLibrary.LoanState.Active) revert LC_InvalidState(data.state);\n\n        uint256 returnAmount = getFullInterestAmount(data.terms.principal, data.terms.interestRate);\n\n        // transfer from msg.sender to this contract\n        IERC20Upgradeable(data.terms.payableCurrency).safeTransferFrom(_msgSender(), address(this), returnAmount);\n\n        // get promissory notes from two parties involved\n        address lender = lenderNote.ownerOf(loanId);\n        address borrower = borrowerNote.ownerOf(loanId);\n\n        // state changes and cleanup\n        // NOTE: these must be performed before assets are released to prevent reentrance\n        loans[loanId].state = LoanLibrary.LoanState.Repaid;\n        collateralInUse[keccak256(abi.encode(data.terms.collateralAddress, data.terms.collateralId))] = false;\n\n        _burnLoanNotes(loanId);\n\n        // asset and collateral redistribution\n        // Not using safeTransfer to prevent lenders from blocking\n        // loan receipt and forcing a default\n        IERC20Upgradeable(data.terms.payableCurrency).transfer(lender, returnAmount);\n        IERC721Upgradeable(data.terms.collateralAddress).transferFrom(address(this), borrower, data.terms.collateralId);\n\n        emit LoanRepaid(loanId);\n    }\n\n    /**\n     * @notice Claim collateral on a given loan. Can only be called by RepaymentController,\n     *         which verifies claim conditions. This method validate that the loan's due\n     *         date has passed, and then distribute collateral to the lender. All promissory\n     *         notes will be burned and the loan will be marked as complete.\n     *\n     * @param loanId                              The ID of the loan to claim.\n     * @param currentInstallmentPeriod            The current installment period if\n     *                                            installment loan type, else 0.\n     */\n    function claim(uint256 loanId, uint256 currentInstallmentPeriod)\n        external\n        override\n        whenNotPaused\n        onlyRole(REPAYER_ROLE)\n    {\n        LoanLibrary.LoanData memory data = loans[loanId];\n        // ensure valid initial loan state when starting loan\n        if (data.state != LoanLibrary.LoanState.Active) revert LC_InvalidState(data.state);\n        // for legacy loans (currentInstallmentPeriod == 0) ensure lender is claiming\n        // after the loan has ended and if so, block.timstamp must be greater than the dueDate.\n        // for installment loan types (currentInstallmentPeriod > 0), check if the loan\n        // is in default, if not, revert.\n        if (data.terms.numInstallments == 0) {\n            uint256 dueDate = data.startDate + data.terms.durationSecs;\n            if (dueDate > block.timestamp) revert LC_NotExpired(dueDate);\n        } else {\n            _verifyDefaultedLoan(data.terms.numInstallments, data.numInstallmentsPaid, currentInstallmentPeriod);\n        }\n\n        address lender = lenderNote.ownerOf(loanId);\n\n        // NOTE: these must be performed before assets are released to prevent reentrance\n        loans[loanId].state = LoanLibrary.LoanState.Defaulted;\n        collateralInUse[keccak256(abi.encode(data.terms.collateralAddress, data.terms.collateralId))] = false;\n\n        _burnLoanNotes(loanId);\n\n        // collateral redistribution\n        IERC721Upgradeable(data.terms.collateralAddress).transferFrom(address(this), lender, data.terms.collateralId);\n\n        emit LoanClaimed(loanId);\n    }\n\n    /**\n     * @notice Roll over a loan, atomically closing one and re-opening a new one with the\n     *         same collateral. Instead of full repayment, only net payments from each\n     *         party are required. Each rolled-over loan is marked as complete, and the new\n     *         loan is given a new unique ID and notes. At the time of calling, any needed\n     *         net payments have been collected by the RepaymentController for withdrawal.\n     *\n     * @param oldLoanId             The ID of the old loan.\n     * @param borrower              The borrower for the loan.\n     * @param lender                The lender for the old loan.\n     * @param terms                 The terms of the new loan.\n     * @param _settledAmount        The amount LoanCore needs to withdraw to settle.\n     * @param _amountToOldLender    The payment to the old lender (if lenders are changing).\n     * @param _amountToLender       The payment to the lender (if same as old lender).\n     * @param _amountToBorrower     The payemnt to the borrower (in the case of leftover principal).\n     *\n     * @return newLoanId            The ID of the new loan.\n     */\n    function rollover(\n        uint256 oldLoanId,\n        address borrower,\n        address lender,\n        LoanLibrary.LoanTerms calldata terms,\n        uint256 _settledAmount,\n        uint256 _amountToOldLender,\n        uint256 _amountToLender,\n        uint256 _amountToBorrower\n    ) external override whenNotPaused onlyRole(ORIGINATOR_ROLE) returns (uint256 newLoanId) {\n        // Repay loan\n        LoanLibrary.LoanData storage data = loans[oldLoanId];\n        data.state = LoanLibrary.LoanState.Repaid;\n\n        address oldLender = lenderNote.ownerOf(oldLoanId);\n        IERC20Upgradeable payableCurrency = IERC20Upgradeable(data.terms.payableCurrency);\n\n        if (data.terms.numInstallments > 0) {\n            (uint256 interestDue, uint256 lateFees, uint256 numMissedPayments) = _calcAmountsDue(\n                data.balance,\n                data.startDate,\n                data.terms.durationSecs,\n                data.terms.numInstallments,\n                data.numInstallmentsPaid,\n                data.terms.interestRate\n            );\n\n            data.lateFeesAccrued += lateFees;\n            data.numInstallmentsPaid += uint24(numMissedPayments) + 1;\n            data.balance = 0;\n            data.balancePaid += data.balance + interestDue + lateFees;\n        }\n\n        _burnLoanNotes(oldLoanId);\n\n        // Set up new loan\n        newLoanId = loanIdTracker.current();\n        loanIdTracker.increment();\n\n        loans[newLoanId] = LoanLibrary.LoanData({\n            terms: terms,\n            state: LoanLibrary.LoanState.Active,\n            startDate: uint160(block.timestamp),\n            balance: terms.principal,\n            balancePaid: 0,\n            lateFeesAccrued: 0,\n            numInstallmentsPaid: 0\n        });\n\n        // Distribute notes and principal\n        _mintLoanNotes(newLoanId, borrower, lender);\n\n        IERC20Upgradeable(payableCurrency).safeTransferFrom(_msgSender(), address(this), _settledAmount);\n        _transferIfNonzero(payableCurrency, oldLender, _amountToOldLender);\n        _transferIfNonzero(payableCurrency, lender, _amountToLender);\n        _transferIfNonzero(payableCurrency, borrower, _amountToBorrower);\n\n        emit LoanRepaid(oldLoanId);\n        emit LoanStarted(newLoanId, lender, borrower);\n        emit LoanRolledOver(oldLoanId, newLoanId);\n    }\n\n    // ===================================== INSTALLMENT OPERATI\\ONS =====================================\n\n    /**\n     * @notice Called from RepaymentController when paying back an installment loan.\n     *         New loan state parameters are calculated in the Repayment Controller.\n     *         Based on if the _paymentToPrincipal is greater than the current balance,\n     *         the loan state is updated. (0 = minimum payment sent, > 0 pay down principal).\n     *         The paymentTotal (_paymentToPrincipal + _paymentToLateFees) is always transferred to the lender.\n     *\n     * @param _loanId                       The ID of the loan..\n     * @param _currentMissedPayments        Number of payments missed since the last isntallment payment.\n     * @param _paymentToPrincipal           Amount sent in addition to minimum amount due, used to pay down principal.\n     * @param _paymentToInterest            Amount due in interest.\n     * @param _paymentToLateFees            Amount due in only late fees.\n     */\n    function repayPart(\n        uint256 _loanId,\n        uint256 _currentMissedPayments,\n        uint256 _paymentToPrincipal,\n        uint256 _paymentToInterest,\n        uint256 _paymentToLateFees\n    ) external override onlyRole(REPAYER_ROLE) {\n        LoanLibrary.LoanData storage data = loans[_loanId];\n        // ensure valid initial loan state when repaying loan\n        if (data.state != LoanLibrary.LoanState.Active) revert LC_InvalidState(data.state);\n\n        // calculate total sent by borrower and transferFrom repayment controller to this address\n        uint256 paymentTotal = _paymentToPrincipal + _paymentToLateFees + _paymentToInterest;\n        IERC20Upgradeable(data.terms.payableCurrency).safeTransferFrom(_msgSender(), address(this), paymentTotal);\n\n        // get the lender and borrower\n        address lender = lenderNote.ownerOf(_loanId);\n        address borrower = borrowerNote.ownerOf(_loanId);\n\n        uint256 _balanceToPay = _paymentToPrincipal;\n        if (_balanceToPay >= data.balance) {\n            _balanceToPay = data.balance;\n\n            // mark loan as closed\n            data.state = LoanLibrary.LoanState.Repaid;\n            collateralInUse[keccak256(abi.encode(data.terms.collateralAddress, data.terms.collateralId))] = false;\n\n            _burnLoanNotes(_loanId);\n        }\n\n        // Unlike paymentTotal, cannot go over maximum amount owed\n        uint256 boundedPaymentTotal = _balanceToPay + _paymentToLateFees + _paymentToInterest;\n\n        // update loan state\n        data.lateFeesAccrued += _paymentToLateFees;\n        data.numInstallmentsPaid += uint24(_currentMissedPayments) + 1;\n        data.balance -= _balanceToPay;\n        data.balancePaid += boundedPaymentTotal;\n\n        // Send payment to lender.\n        // Not using safeTransfer to prevent lenders from blocking\n        // loan receipt and forcing a default\n        IERC20Upgradeable(data.terms.payableCurrency).transfer(lender, boundedPaymentTotal);\n\n        // If repaid, send collateral to borrower\n        if (data.state == LoanLibrary.LoanState.Repaid) {\n            IERC721Upgradeable(data.terms.collateralAddress).transferFrom(\n                address(this),\n                borrower,\n                data.terms.collateralId\n            );\n\n            if (_paymentToPrincipal > _balanceToPay) {\n                // Borrower overpaid, so send refund\n                IERC20Upgradeable(data.terms.payableCurrency).safeTransfer(\n                    borrower,\n                    _paymentToPrincipal - _balanceToPay\n                );\n            }\n\n            emit LoanRepaid(_loanId);\n        } else {\n            // minimum repayment events will emit 0 and unchanged principal\n            emit InstallmentPaymentReceived(_loanId, _paymentToPrincipal, data.balance);\n        }\n    }\n\n    // ======================================== NONCE MANAGEMENT ========================================\n\n    /**\n     * @notice Mark a nonce as used in the context of starting a loan. Reverts if\n     *         nonce has already been used. Can only be called by Origination Controller.\n     *\n     * @param user                  The user for whom to consume a nonce.\n     * @param nonce                 The nonce to consume.\n     */\n    function consumeNonce(address user, uint160 nonce) external override whenNotPaused onlyRole(ORIGINATOR_ROLE) {\n        _useNonce(user, nonce);\n    }\n\n    /**\n     * @notice Mark a nonce as used in order to invalidate signatures with the nonce.\n     *         Does not allow specifying the user, and automatically consumes the nonce\n     *         of the caller.\n     *\n     * @param nonce                 The nonce to consume.\n     */\n    function cancelNonce(uint160 nonce) external override {\n        address user = _msgSender();\n        _useNonce(user, nonce);\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    /**\n     * @notice Returns the LoanData struct for the specified loan ID.\n     *\n     * @param loanId                The ID of the given loan.\n     *\n     * @return loanData             The struct containing loan state and terms.\n     */\n    function getLoan(uint256 loanId) external view override returns (LoanLibrary.LoanData memory loanData) {\n        return loans[loanId];\n    }\n\n    /**\n     * @notice Reports if the caller is allowed to call functions on the given vault.\n     *         Determined by if they are the borrower for the loan, defined by ownership\n     *         of the relevant BorrowerNote.\n     *\n     * @dev Implemented as part of the ICallDelegator interface.\n     *\n     * @param caller                The user that wants to call a function.\n     * @param vault                 The vault that the caller wants to call a function on.\n     *\n     * @return allowed              True if the caller is allowed to call on the vault.\n     */\n    function canCallOn(address caller, address vault) external view override returns (bool) {\n        // if the collateral is not currently being used in a loan, disallow\n        if (!collateralInUse[keccak256(abi.encode(OwnableERC721(vault).ownershipToken(), uint256(uint160(vault))))]) {\n            return false;\n        }\n        for (uint256 i = 0; i < borrowerNote.balanceOf(caller); i++) {\n            uint256 loanId = borrowerNote.tokenOfOwnerByIndex(caller, i);\n\n            // if the borrower is currently borrowing against this vault,\n            // return true\n            if (loans[loanId].terms.collateralId == uint256(uint160(vault))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Reports whether the given nonce has been previously used by a user. Returning\n     *         false does not mean that the nonce will not clash with another potential off-chain\n     *         signature that is stored somewhere.\n     *\n     * @param user                  The user to check the nonce for.\n     * @param nonce                 The nonce to check.\n     *\n     * @return used                 Whether the nonce has been used.\n     */\n    function isNonceUsed(address user, uint160 nonce) external view override returns (bool) {\n        return usedNonces[user][nonce];\n    }\n\n    // ======================================== ADMIN FUNCTIONS =========================================\n\n    /**\n     * @notice Sets the fee controller to a new address. It must implement the\n     *         IFeeController interface. Can only be called by the contract owner.\n     *\n     * @param _newController        The new fee controller contract.\n     */\n    function setFeeController(IFeeController _newController) external onlyRole(FEE_CLAIMER_ROLE) {\n        if (address(_newController) == address(0)) revert LC_ZeroAddress();\n\n        feeController = _newController;\n\n        emit SetFeeController(address(feeController));\n    }\n\n    /**\n     * @notice Claim the protocol fees for the given token. Any token used as principal\n     *         for a loan will have accumulated fees. Must be called by contract owner.\n     *\n     * @param token                 The contract address of the token to claim fees for.\n     */\n    function claimFees(IERC20Upgradeable token) external onlyRole(FEE_CLAIMER_ROLE) {\n        // any token balances remaining on this contract are fees owned by the protocol\n        uint256 amount = token.balanceOf(address(this));\n        token.safeTransfer(_msgSender(), amount);\n        emit FeesClaimed(address(token), _msgSender(), amount);\n    }\n\n    /**\n     * @notice Pauses the contract, preventing loan lifecyle operations.\n     *         Should only be used in case of emergency. Can only be called\n     *         by contract owner.\n     */\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses the contract, enabling loan lifecyle operations.\n     *         Can be used after pausing due to emergency or during contract\n     *         upgrade. Can only be called by contract owner.\n     */\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    // ============================================= HELPERS ============================================\n\n    /**\n     * @dev Takes a principal value and returns the amount that will be distributed\n     *      to the borrower after protocol fees.\n     *\n     * @param principal             The principal amount.\n     *\n     * @return principalLessFees    The amount after fees.\n     */\n    function _getPrincipalLessFees(uint256 principal) internal view returns (uint256) {\n        return principal - (principal * feeController.getOriginationFee()) / BASIS_POINTS_DENOMINATOR;\n    }\n\n    /**\n     * @dev Consume a nonce, by marking it as used for that user. Reverts if the nonce\n     *      has already been used.\n     *\n     * @param user                  The user for whom to consume a nonce.\n     * @param nonce                 The nonce to consume.\n     */\n    function _useNonce(address user, uint160 nonce) internal {\n        if (usedNonces[user][nonce]) revert LC_NonceUsed(user, nonce);\n        // set nonce to used\n        usedNonces[user][nonce] = true;\n\n        emit NonceUsed(user, nonce);\n    }\n\n    /**\n     * @notice Check collateral is available to claim via default.\n     *         This function passes when the last payment made by the borrower\n     *         was made over 40% of the total number of installment periods previously.\n     *         For example a loan with 10 installment periods. The borrower would\n     *         have to miss 4 consecutive payments during the loan to default.\n     *\n     * @dev Missed payments checked are consecutive due how the numInstallmentsPaid\n     *      value in LoanData is being updated to the current installment period\n     *      everytime a repayment at any time is made for an installment loan.\n     *      (numInstallmentsPaid += _currentMissedPayments + 1).\n     *\n     * @param numInstallments                  Total number of installments in loan.\n     * @param numInstallmentsPaid              Installment period of the last installment payment.\n     * @param currentInstallmentPeriod         Current installment period call made in.\n     */\n    function _verifyDefaultedLoan(\n        uint256 numInstallments,\n        uint256 numInstallmentsPaid,\n        uint256 currentInstallmentPeriod\n    ) internal pure {\n        // make sure if called in the same installment period as payment was made,\n        // does not get to currentInstallmentsMissed calculation. needs to be first.\n        if (numInstallmentsPaid == currentInstallmentPeriod) revert LC_LoanNotDefaulted();\n\n        // get installments missed necessary for loan default (*1000)\n        uint256 installmentsMissedForDefault = ((numInstallments * PERCENT_MISSED_FOR_LENDER_CLAIM) * 1000) /\n            BASIS_POINTS_DENOMINATOR;\n        // get current installments missed (*1000)\n        // one added to numInstallmentsPaid for a grace period on the current installment.\n        uint256 currentInstallmentsMissed = ((currentInstallmentPeriod) * 1000) - ((numInstallmentsPaid + 1) * 1000);\n\n        // check if the number of missed payments is greater than\n        // 40% the total number of installment periods\n        if (currentInstallmentsMissed < installmentsMissedForDefault) revert LC_LoanNotDefaulted();\n    }\n\n    /*\n     * @dev Mint a borrower and lender note together - eiaser to make sure\n     *      they are synchronized.\n     *\n     * @param loanId                The token ID to mint.\n     * @param borrower              The address of the recipient of the borrower note.\n     * @param lender                The address of the recpient of the lender note.\n     */\n    function _mintLoanNotes(\n        uint256 loanId,\n        address borrower,\n        address lender\n    ) internal {\n        borrowerNote.mint(borrower, loanId);\n        lenderNote.mint(lender, loanId);\n    }\n\n    /**\n     * @dev Burn a borrower and lender note together - eiaser to make sure\n     *      they are synchronized.\n     *\n     * @param loanId                The token ID to burn.\n     */\n    function _burnLoanNotes(uint256 loanId) internal {\n        lenderNote.burn(loanId);\n        borrowerNote.burn(loanId);\n    }\n\n    /**\n     * @dev Perform an ERC20 transfer, if the specified amount is nonzero - else no-op.\n     *\n     * @param token                 The token to transfer.\n     * @param to                    The address receiving the tokens.\n     * @param amount                The amount of tokens to transfer.\n     */\n    function _transferIfNonzero(\n        IERC20Upgradeable token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) token.safeTransfer(to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/test/LoanCoreV2Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../LoanCore.sol\";\n\ncontract LoanCoreV2Mock is LoanCore {\n    function version() public pure returns (string memory) {\n        return \"This is LoanCore V2!\";\n    }\n}\n"
    },
    "contracts/FeeController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IFeeController.sol\";\n\n/**\n * @title FeeController\n * @author Non-Fungible Technologies, Inc.\n *\n * The Fee Controller is used by LoanCore to query for fees for different\n * loan lifecycle interactions (origiations, rollovers, etc). All fees should\n * have setters and getters and be expressed in BPs. In the future, this contract\n * could be extended to support more complext logic (introducing a mapping of users\n * who get a discount, e.g.). Since LoanCore can change the fee controller reference,\n * any changes to this contract can be newly deployed on-chain and adopted.\n */\ncontract FeeController is AccessControlEnumerable, IFeeController, Ownable {\n    // ============================================ STATE ==============================================\n\n    /// @dev Fee for origination - default is 0.5%\n    uint256 private originationFee = 50;\n    /// @dev Fee for rollovers - default is 0.1%\n    uint256 private rolloverFee = 10;\n\n    // ========================================= FEE SETTERS ===========================================\n\n    /**\n     * @notice Set the origination fee to the given value. The caller\n     *         must be the owner of the contract.\n     *\n     * @param _originationFee       The new origination fee, in bps.\n     */\n    function setOriginationFee(uint256 _originationFee) external override onlyOwner {\n        originationFee = _originationFee;\n        emit UpdateOriginationFee(_originationFee);\n    }\n\n    /**\n     * @notice Set the origination fee to the given value. The caller\n     *         must be the owner of the contract.\n     *\n     * @param _rolloverFee          The new rollover fee, in bps.\n     */\n    function setRolloverFee(uint256 _rolloverFee) external override onlyOwner {\n        rolloverFee = _rolloverFee;\n        emit UpdateRolloverFee(_rolloverFee);\n    }\n\n    // ========================================= FEE GETTERS ===========================================\n\n    /**\n     * @notice Get the current origination fee in bps.\n     *\n     * @return originationFee       The current fee in bps.\n     */\n    function getOriginationFee() public view override returns (uint256) {\n        return originationFee;\n    }\n\n    // ========================================= FEE GETTERS ===========================================\n\n    /**\n     * @notice Get the current origination fee in bps.\n     *\n     * @return rolloverFee       The current fee in bps.\n     */\n    function getRolloverFee() public view override returns (uint256) {\n        return rolloverFee;\n    }\n}\n"
    },
    "contracts/vault/CallWhitelist.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ICallWhitelist.sol\";\n\n/**\n * @title CallWhitelist\n * @author Non-Fungible Technologies, Inc.\n *\n * Maintains a whitelist for calls that can be made from an AssetVault.\n * Intended to be used to allow for \"claim\" and other-utility based\n * functions while an asset is being held in escrow. Some functions\n * are blacklisted, e.g. transfer functions, to prevent callers from\n * being able to circumvent withdrawal rules for escrowed assets.\n * Whitelists are specified in terms of \"target contract\" (callee)\n * and function selector.\n *\n * The contract owner can add or remove items from the whitelist.\n */\ncontract CallWhitelist is Ownable, ICallWhitelist {\n    // ============================================ STATE ==============================================\n\n    // ============= Global Immutable State ==============\n\n    /**\n     * @dev Global blacklist for transfer functions.\n     */\n    bytes4 private constant ERC20_TRANSFER = 0xa9059cbb;\n    bytes4 private constant ERC20_ERC721_APPROVE = 0x095ea7b3;\n    bytes4 private constant ERC20_ERC721_TRANSFER_FROM = 0x23b872dd;\n\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = 0x42842e0e;\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_DATA = 0xb88d4fde;\n    bytes4 private constant ERC721_ERC1155_SET_APPROVAL = 0xa22cb465;\n\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM = 0xf242432a;\n    bytes4 private constant ERC1155_SAFE_BATCH_TRANSFER_FROM = 0x2eb2c2d6;\n\n    // ================= Whitelist State ==================\n\n    /**\n     * @notice Whitelist of callable functions on contracts. Maps addresses that\n     *         can be called to function selectors which can be called on it.\n     *         For example, if we want to allow function call 0x0000 on a contract\n     *         at 0x1111, the mapping will contain whitelist[0x1111][0x0000] = true.\n     */\n    mapping(address => mapping(bytes4 => bool)) private whitelist;\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    /**\n     * @notice Returns true if the given function on the given callee is whitelisted.\n     *\n     * @param callee                The contract that is intended to be called.\n     * @param selector              The function selector that is intended to be called.\n     *\n     * @return isWhitelisted        True if whitelisted, else false.\n     */\n    function isWhitelisted(address callee, bytes4 selector) external view override returns (bool) {\n        return !isBlacklisted(selector) && whitelist[callee][selector];\n    }\n\n    /**\n     * @notice Returns true if the given function selector is on the global blacklist.\n     *         Blacklisted function selectors cannot be called on any contract.\n     *\n     * @param selector              The function selector to check.\n     *\n     * @return isBlacklisted        True if blacklisted, else false.\n     */\n    function isBlacklisted(bytes4 selector) public pure override returns (bool) {\n        return\n            selector == ERC20_TRANSFER ||\n            selector == ERC20_ERC721_APPROVE ||\n            selector == ERC20_ERC721_TRANSFER_FROM ||\n            selector == ERC721_SAFE_TRANSFER_FROM ||\n            selector == ERC721_SAFE_TRANSFER_FROM_DATA ||\n            selector == ERC721_ERC1155_SET_APPROVAL ||\n            selector == ERC1155_SAFE_TRANSFER_FROM ||\n            selector == ERC1155_SAFE_BATCH_TRANSFER_FROM;\n    }\n\n    // ======================================== UPDATE OPERATIONS =======================================\n\n    /**\n     * @notice Add the given callee and selector to the whitelist. Can only be called by owner.\n     * @dev    A blacklist supersedes a whitelist, so should not add blacklisted selectors.\n     *\n     * @param callee                The contract to whitelist.\n     * @param selector              The function selector to whitelist.\n     */\n    function add(address callee, bytes4 selector) external override onlyOwner {\n        whitelist[callee][selector] = true;\n        emit CallAdded(msg.sender, callee, selector);\n    }\n\n    /**\n     * @notice Remove the given calle and selector from the whitelist. Can only be called by owner.\n     *\n     * @param callee                The contract to whitelist.\n     * @param selector              The function selector to whitelist.\n     */\n    function remove(address callee, bytes4 selector) external override onlyOwner {\n        whitelist[callee][selector] = false;\n        emit CallRemoved(msg.sender, callee, selector);\n    }\n}\n"
    },
    "contracts/test/MockERC1271Lender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport \"../interfaces/IOriginationController.sol\";\n\ncontract ERC1271LenderMock is IERC1271 {\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\n\n    function approve(address token, address target) external {\n        IERC20(token).approve(target, type(uint256).max);\n    }\n\n    function isValidSignature(bytes32, bytes memory) public pure override returns (bytes4 magicValue) {\n        return MAGICVALUE;\n    }\n}\n"
    },
    "contracts/test/MockCallDelegator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../interfaces/ICallDelegator.sol\";\n\ncontract MockCallDelegator is ICallDelegator {\n    bool private canCall;\n\n    /**\n     * @inheritdoc ICallDelegator\n     */\n    function canCallOn(address caller, address vault) external view override returns (bool) {\n        require(caller != vault, \"Invalid vault\");\n        return canCall;\n    }\n\n    function setCanCall(bool _canCall) external {\n        canCall = _canCall;\n    }\n}\n"
    },
    "contracts/test/VaultFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../vault/VaultFactory.sol\";\n\ncontract VaultFactoryV2 is VaultFactory {\n    function version() public pure returns (string memory) {\n        return \"This is VaultFactory V2!\";\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/test/Templates.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/presets/ERC1155PresetMinterPauser.sol\";\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\n\ncontract MockERC20 is Context, ERC20Burnable {\n    /**\n     * @dev Initializes ERC20 token\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    /**\n     * @dev Creates `amount` new tokens for `to`. Public for any test to call.\n     *\n     * See {ERC20-_mint}.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        _mint(to, amount);\n    }\n}\n\ncontract MockERC20WithDecimals is ERC20PresetMinterPauser {\n    uint8 private _decimals;\n\n    /**\n     * @dev Initializes ERC20 token\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals_\n    ) ERC20PresetMinterPauser(name, symbol) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/test/MockERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract MockERC1155 is Context, ERC1155 {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdTracker;\n\n    /**\n     * @dev Initializes ERC1155 token\n     */\n    constructor() ERC1155(\"\") {}\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        _mint(to, _tokenIdTracker.current(), amount, \"\");\n        _tokenIdTracker.increment();\n    }\n}\n\ncontract MockERC1155Metadata is MockERC1155 {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdTracker;\n\n    mapping(uint256 => string) public tokenURIs;\n\n    constructor() MockERC1155() {}\n\n    function mint(\n        address to,\n        uint256 amount,\n        string memory tokenUri\n    ) public virtual {\n        uint256 tokenId = _tokenIdTracker.current();\n        _mint(to, tokenId, amount, \"\");\n        _tokenIdTracker.increment();\n        _setTokenURI(tokenId, tokenUri);\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        string[] memory tokenUris,\n        bytes memory data\n    ) public virtual {\n        super._mintBatch(to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _setTokenURI(ids[i], tokenUris[i]);\n        }\n    }\n\n    function _setTokenURI(uint256 tokenId, string memory tokenUri) internal {\n        tokenURIs[tokenId] = tokenUri;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}